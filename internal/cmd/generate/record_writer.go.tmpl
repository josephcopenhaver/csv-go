{{- $appendBytesRec0 := "" }}{{if .Memclear}}{{ $appendBytesRec0 = "rw.appendRec(" }}{{else}}{{ $appendBytesRec0 = "rw.recordBuf = append(rw.recordBuf, " }}{{end}}
{{ $appendStrRec0 := "" }}{{if .Memclear}}{{ $appendStrRec0 = "rw.appendStrRec(" }}{{else}}{{ $appendStrRec0 = "rw.recordBuf = append(rw.recordBuf, " }}{{end}}
{{ $appendRec0 := $appendBytesRec0 }}
{{ $appendRec1 := "" }}{{if .Memclear}}{{ $appendRec1 = ")" }}{{else}}{{ $appendRec1 = "...)" }}{{end}}
{{ $setRec0 := "" }}{{if .Memclear}}{{ $setRec0 = "rw.setRecordBuf(" }}{{else}}{{ $setRec0 = "rw.recordBuf = " }}{{end}}
{{ $setRec1 := "" }}{{if .Memclear}}{{ $setRec1 = ")" }}{{- end}}

func (rw *RecordWriter) preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() bool {
	if rw.err != nil {
		return false
	}

	if err := rw.w.err; err != nil {
		rw.err = err
		return false
	}

	if rw.nextField != 0 {
		{{$setRec0}}rw.w.fieldSepSeq.appendText(rw.recordBuf){{$setRec1}}
	} else {
		if (rw.bitFlags & wFlagClosed) != 0 {
			panic("must not reuse record references after they are written or aborted")
		}
		rw.bitFlags = rw.w.bitFlags
		rw.numFields = rw.w.numFields
		rw.recordBuf = rw.recordBuf[:0]
		if rw.w.comment != invalidControlRune && (rw.bitFlags&wFlagFirstRecordWritten) == 0 {
			rw.bitFlags |= wFlagForceQuoteFirstField
		}
	}

	nextField := rw.nextField + 1
	if nextField <= 0 {
		panic("too many fields: integer overflow")
	}
	rw.nextField = nextField

	return true
}

func (rw *RecordWriter) unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(p []byte) {
	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		i = rw.w.controlRuneSet.indexAnyInBytes(p)
		if i == -1 {
			{{$appendRec0}}p{{$appendRec1}}
			return
		}
	}

	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
	rw.loadQF_memclearO{{if .Memclear}}n{{else}}ff{{end}}(p, i)
	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
}

func (rw *RecordWriter) bytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(p []byte) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags&wFlagErrOnNonUTF8) != 0 && !utf8.Valid(p) {
		rw.err = ErrNonUTF8InRecord
		return rw
	}

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		i = rw.w.controlRuneSet.indexAnyInBytes(p)
		if i == -1 {
			{{$appendRec0}}p{{$appendRec1}}
			return rw
		}
	}

	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
	rw.loadQF_memclearO{{if .Memclear}}n{{else}}ff{{end}}(p, i)
	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}

	return rw
}

func (rw *RecordWriter) string_memclearO{{if .Memclear}}n{{else}}ff{{end}}(s string) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags&wFlagErrOnNonUTF8) != 0 && !utf8.ValidString(s) {
		rw.err = ErrNonUTF8InRecord
		return rw
	}

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !strings.HasPrefix(s, string(rw.w.comment)) {
		i = rw.w.controlRuneSet.indexAnyInString(s)
		if i == -1 {
			{{$appendStrRec0}}s{{$appendRec1}}
			return rw
		}
	}

	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
	rw.loadStrQF_memclearO{{if .Memclear}}n{{else}}ff{{end}}(s, i)
	{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}

	return rw
}

func (rw *RecordWriter) int64_memclearO{{if .Memclear}}n{{else}}ff{{end}}(i int64) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		{{$setRec0}}strconv.AppendInt(rw.recordBuf, i, 10){{$setRec1}}
		return rw
	}

	rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(strconv.AppendInt(rw.w.fieldWriterBuf[:0], i, 10))
	return rw
}

func (rw *RecordWriter) uint64_memclearO{{if .Memclear}}n{{else}}ff{{end}}(i uint64) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		{{$setRec0}}strconv.AppendUint(rw.recordBuf, i, 10){{$setRec1}}
		return rw
	}

	rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(strconv.AppendUint(rw.w.fieldWriterBuf[:0], i, 10))
	return rw
}

func (rw *RecordWriter) time_memclearO{{if .Memclear}}n{{else}}ff{{end}}(t time.Time) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		{{$setRec0}}t.AppendFormat(rw.recordBuf, time.RFC3339Nano){{$setRec1}}
		return rw
	}

	rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(t.AppendFormat(rw.w.fieldWriterBuf[:0], time.RFC3339Nano))
	return rw
}

func (rw *RecordWriter) bool_memclearO{{if .Memclear}}n{{else}}ff{{end}}(b bool) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	v := byte('0')
	if b {
		v += 1
	}
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		{{$setRec0}}append(rw.recordBuf, v){{$setRec1}}
	} else {
		rw.w.fieldWriterBuf[0] = v
		rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(rw.w.fieldWriterBuf[:1])
	}

	return rw
}

func (rw *RecordWriter) float64_memclearO{{if .Memclear}}n{{else}}ff{{end}}(f float64) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		{{$setRec0}}strconv.AppendFloat(rw.recordBuf, f, 'g', -1, 64){{$setRec1}}
	} else {
		rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(strconv.AppendFloat(rw.w.fieldWriterBuf[:0], f, 'g', -1, 64))
	}

	return rw
}

func (rw *RecordWriter) rune_memclearO{{if .Memclear}}n{{else}}ff{{end}}(r rune) *RecordWriter {
	if !rw.preflightCheck_memclearO{{if .Memclear}}n{{else}}ff{{end}}() {
		return rw
	}

	if !utf8.ValidRune(r) {
		rw.err = ErrInvalidRune
		return rw
	}

	if (rw.bitFlags & wFlagForceQuoteFirstField) == 0 {
		if r < utf8.RuneSelf {
			if !rw.w.controlRuneSet.containsSingleByteRune(byte(r)) {
				goto SIMPLE_APPEND
			}
		} else if !rw.w.controlRuneSet.containsMBRune(r) {
			goto SIMPLE_APPEND
		}
	}

	rw.unsafeAppendUTF8FieldBytes_memclearO{{if .Memclear}}n{{else}}ff{{end}}(utf8.AppendRune(rw.w.fieldWriterBuf[:0], r))
	return rw

SIMPLE_APPEND:
	{{$setRec0}}utf8.AppendRune(rw.recordBuf, r){{$setRec1}}
	return rw
}

func (rw *RecordWriter) write_memclearO{{if .Memclear}}n{{else}}ff{{end}}() (int, error) {
	if err := rw.err; err != nil {
		return 0, err
	}

	switch rw.nextField {
	case 0:
		if err := rw.w.err; err != nil {
			return 0, err
		}
		err := ErrRowNilOrEmpty
		rw.err = err
		return 0, err
	case 1:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = 1
		} else if numFields != 1 {
			err := ErrInvalidFieldCountInRecord
			rw.err = err
			return 0, err
		}
		if len(rw.recordBuf) == 0 {
			{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
			{{$setRec0}}rw.w.quoteSeq.appendText(rw.recordBuf){{$setRec1}}
		}
	default:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = rw.nextField
		} else if numFields != rw.nextField {
			err := ErrInvalidFieldCountInRecord
			rw.err = err
			return 0, err
		}
	}

	recordBuf := rw.w.recordSepSeq.appendText(rw.recordBuf)
	rw.recordBuf = nil
	rw.nextField = 0
	rw.bitFlags |= wFlagClosed
	rw.w.recordBuf, recordBuf = recordBuf, rw.w.recordBuf
	rw.w.bitFlags |= wFlagFirstRecordWritten

	if recordBuf != nil {
		if (rw.bitFlags & wFlagClearMemoryAfterFree) != 0 {
			clear(recordBuf[:cap(recordBuf)])
		}
		panic("improper concurrent access detected during write")
	}

	if (rw.w.bitFlags & wFlagClosed) != 0 {
		if (rw.bitFlags & wFlagClearMemoryAfterFree) != 0 {
			clear(rw.w.recordBuf[:cap(rw.w.recordBuf)])
		}
		err := ErrWriterClosed
		rw.err = err
		return 0, err
	}

	n, err := rw.w.writer.Write(rw.w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
		rw.err = err
		if rw.w.err == nil {
			rw.w.setErr(err)
		}
	}
	return n, err
}
