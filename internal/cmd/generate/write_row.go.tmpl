{{- define "appendRec0"}}{{if .Memclear}}w.appendRec({{else}}w.recordBuf = append(w.recordBuf, {{end}}{{end}}
{{define "appendRec1"}}{{if .Memclear}}){{else}}...){{end}}{{end -}}
{{define "loadQF"}}w.loadQF_memclearO{{if .Memclear}}n{{else}}ff{{end}}{{end}}
{{define "loadQFCheckUTF8"}}w.loadQFWithCheckUTF8_memclearO{{if .Memclear}}n{{else}}ff{{end}}{{end}}

func (w *Writer) writeRow_memclearO{{if .Memclear}}n{{else}}ff{{end}}(fields []FieldWriter) (int, error) {
	defer func() {
		w.recordBuf = w.recordBuf[:0]
	}()

	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					{{template "appendRec0" .}}w.twoQuotes[:w.twoQuotesByteLen]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.recordSepBytes[:w.recordSepByteLen]{{template "appendRec1" .}}

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					{{template "appendRec0" .}}w.twoQuotes[:w.twoQuotesByteLen]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.recordSepBytes[:w.recordSepByteLen]{{template "appendRec1" .}}

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap|wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				{{if .Memclear}}w.setRecordBuf(src){{else}}w.recordBuf = src{{end}}
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					{{template "appendRec0" .}}src{{template "appendRec1" .}}
					goto FIRST_FIELD_WRITTEN
				}
			}

			{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

			r, n := utf8.DecodeRune(src[i:])
			switch r {
			case w.quote:
				{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
				{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
				{{template "loadQF" .}}(src, i+n, i+n)
			case w.escape:
				{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
				{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
				{{template "loadQF" .}}(src, i+n, i+n)
			default:
				{{template "loadQF" .}}(src, 0, i+n)
			}

			{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		i := 0
		for {
			r, n := utf8.DecodeRune(src[i:])
			if n == 0 {
				// all good and no overlap issues, so just directly copy src
				{{template "appendRec0" .}}src{{template "appendRec1" .}}
				break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
			}
			if n == 1 && r == utf8.RuneError {
				return 0, ErrNonUTF8InRecord
			}

			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 && !strings.ContainsRune(w.controlRunes, r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

			switch r {
			case w.quote:
				{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
				{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
				err = {{template "loadQFCheckUTF8" .}}(src, i+n, i+n)
			case w.escape:
				{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
				{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
				err = {{template "loadQFCheckUTF8" .}}(src, i+n, i+n)
			default:
				err = {{template "loadQFCheckUTF8" .}}(src, 0, i+n)
			}
			if err != nil {
				return 0, err
			}

			{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

			break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
		}
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		{{template "appendRec0" .}}w.fieldSepBytes[:w.fieldSepByteLen]{{template "appendRec1" .}}

SUBSEQUENT_FIELD_WRITE:
		for {
			f := &fields[i]

			var scanForNonUTF8 bool
			var src []byte
			var err error

			switch f.kind {
			case wfkBytes:
				src = f.bytes
				if len(src) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
			case wfkString:
				s := f.str
				if len(s) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
				src = unsafe.Slice(unsafe.StringData(s), len(s))
			case wfkRune:
				src, err = f.runeAppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}

				// src is now guaranteed to be a utf8 encoded non-empty byte sequence
				// so scanForNonUTF8 will remain false here intentionally
			default:
				if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
					src, err = f.AppendText(w.recordBuf)
					if err != nil {
						return 0, err
					}

					{{if .Memclear}}w.setRecordBuf(src){{else}}w.recordBuf = src{{end}}
					break SUBSEQUENT_FIELD_WRITE
				}

				src, err = f.AppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}
			}

			//
			// process src buf
			//

			if !scanForNonUTF8 || (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
				// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

				i := bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					{{template "appendRec0" .}}src{{template "appendRec1" .}}
					break
				}

				{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

				r, n := utf8.DecodeRune(src[i:])
				switch r {
				case w.quote:
					{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
					{{template "loadQF" .}}(src, i+n, i+n)
				case w.escape:
					{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
					{{template "loadQF" .}}(src, i+n, i+n)
				default:
					{{template "loadQF" .}}(src, 0, i+n)
				}

				{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

				break
			}

			// for each decoded rune, check if that rune fails to decode and if so then return an error
			// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
			// continue loading

			i := 0
			for {
				r, n := utf8.DecodeRune(src[i:])
				if n == 0 {
					// all good and no overlap issues, so just directly copy src
					{{template "appendRec0" .}}src{{template "appendRec1" .}}
					break
				}
				if n == 1 && r == utf8.RuneError {
					return 0, ErrNonUTF8InRecord
				}

				if !strings.ContainsRune(w.controlRunes, r) {
					i += n
					continue
				}

				//
				// found a control rune of some kind
				//

				{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

				switch r {
				case w.quote:
					{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
					err = {{template "loadQFCheckUTF8" .}}(src, i+n, i+n)
				case w.escape:
					{{template "appendRec0" .}}src[:i]{{template "appendRec1" .}}
					{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
					err = {{template "loadQFCheckUTF8" .}}(src, i+n, i+n)
				default:
					err = {{template "loadQFCheckUTF8" .}}(src, 0, i+n)
				}
				if err != nil {
					return 0, err
				}

				{{template "appendRec0" .}}w.quoteBytes[:w.quoteByteLen]{{template "appendRec1" .}}

				break
			}

			break
		}
	}

	{{template "appendRec0" .}}w.recordSepBytes[:w.recordSepByteLen]{{template "appendRec1" .}}

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}
