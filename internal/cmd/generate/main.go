//go:generate go run main.go
package main

import (
	"bytes"
	_ "embed"
	"go/format"
	"io"
	"os"
	"text/template"
)

//go:embed imports.go.tmpl
var tsImports string

//go:embed prepare_row.go.tmpl
var tsPrepareRow string

//go:embed process_field.go.tmpl
var tsProcessField string

//go:embed escape_chars.go.tmpl
var tsEscapeChars string

//go:embed write.go.tmpl
var tsWrite string

func parse(s string) *template.Template {
	t, err := template.New("").Option("missingkey=error").Parse(s)
	if err != nil {
		panic(err)
	}
	return t
}

func renderer[T any](w io.Writer) func(*template.Template, []T) {
	return func(t *template.Template, data []T) {
		if len(data) == 0 {
			if err := t.Execute(w, nil); err != nil {
				panic(err)
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				panic(err)
			}
			return
		}

		for _, d := range data {
			if err := t.Execute(w, d); err != nil {
				panic(err)
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				panic(err)
			}
		}
	}
}

func main() {
	const dstFile = "../../../gen_strategies.go"

	defer func() {
		if r := recover(); r != nil {
			defer panic(r)
			os.Remove(dstFile)
			return
		}
	}()

	f, err := os.Create(dstFile)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			v := any(err)
			if r := recover(); r != nil {
				v = r
			}
			panic(v)
		}
	}()

	var buf bytes.Buffer

	_, err = buf.WriteString(`// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.` + "\n\n")
	if err != nil {
		panic(err)
	}

	// create imports section of source code
	{
		render := renderer[any](&buf)

		render(parse(tsImports), nil)
	}

	// render prepareRow strategies
	{
		t := parse(tsPrepareRow)

		type cfg struct {
			Struct                 string
			NameSuffix             string
			RecBufAppend0          string
			RecBufAppend1          string
			DeltaCommentBytesCheck string
			CommentLinesCheck      string
			IncRecordIndex         string
			SetFieldStart          string
			NotQuotePossible       bool
		}

		render := renderer[cfg](&buf)

		const quoteOnSetFieldStart = "r.fieldStart = len(r.recordBuf)"

		render(t, []cfg{
			{
				Struct:         "fastReader",
				RecBufAppend0:  "r.recordBuf = append(r.recordBuf, ",
				RecBufAppend1:  ")",
				IncRecordIndex: "r.recordIndex++",
				SetFieldStart:  quoteOnSetFieldStart,
			},
			{
				Struct:                 "secOpReader",
				NameSuffix:             "_memclearOn",
				RecBufAppend0:          "if r.appendRecBuf(",
				RecBufAppend1:          ") {return false}",
				IncRecordIndex:         "r.incRecordIndex()",
				DeltaCommentBytesCheck: "if r.outOfCommentBytes(delta) {return false}",
				CommentLinesCheck:      "if r.outOfCommentLines() {return false}",
				SetFieldStart:          quoteOnSetFieldStart,
			},
		})
	}

	// render processField strategies
	{
		t := parse(tsProcessField)

		type cfg struct {
			Escape              bool
			ForceQuote          bool
			ClearMemoryAfterUse bool
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{Escape: false, ForceQuote: false, ClearMemoryAfterUse: false},
			{Escape: true, ForceQuote: false, ClearMemoryAfterUse: false},
			{Escape: false, ForceQuote: true, ClearMemoryAfterUse: false},
			{Escape: true, ForceQuote: true, ClearMemoryAfterUse: false},
			{Escape: false, ForceQuote: false, ClearMemoryAfterUse: true},
			{Escape: true, ForceQuote: false, ClearMemoryAfterUse: true},
			{Escape: false, ForceQuote: true, ClearMemoryAfterUse: true},
			{Escape: true, ForceQuote: true, ClearMemoryAfterUse: true},
		})
	}

	// render EscapeChars strategies
	{
		t := parse(tsEscapeChars)

		type cfg struct {
			Escape              bool
			ClearMemoryAfterUse bool
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{Escape: false, ClearMemoryAfterUse: false},
			{Escape: true, ClearMemoryAfterUse: false},
			{Escape: false, ClearMemoryAfterUse: true},
			{Escape: true, ClearMemoryAfterUse: true},
		})
	}

	// render writing strategies
	{
		t := parse(tsWrite)

		type cfg struct {
			ClearMemoryAfterUse bool
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{ClearMemoryAfterUse: false},
			{ClearMemoryAfterUse: true},
		})
	}

	// // for debugging
	// _, err = f.Write(buf.Bytes())
	// if err != nil {
	// 	panic(err)
	// } else {
	// 	return
	// }

	b, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	_, err = f.Write(b)
	if err != nil {
		panic(err)
	}
}
