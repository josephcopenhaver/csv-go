//go:generate go run main.go
package main

import (
	"bytes"
	_ "embed"
	"go/format"
	"io"
	"os"
	"text/template"
)

//go:embed imports.go.tmpl
var tsImports string

//go:embed prepare_row.go.tmpl
var tsPrepareRow string

//go:embed write.go.tmpl
var tsWrite string

//go:embed fast_csv_rune_set.go.tmpl
var tsRuneSet string

//go:embed record_writer.go.tmpl
var tsRecordWriter string

//go:embed write_buffer.go.tmpl
var tsWriteBuffer string

func parse(s string) *template.Template {
	t, err := template.New("").Option("missingkey=error").Parse(s)
	if err != nil {
		panic(err)
	}
	return t
}

func renderer[T any](w io.Writer) func(*template.Template, []T) {
	return func(t *template.Template, data []T) {
		if len(data) == 0 {
			if err := t.Execute(w, nil); err != nil {
				panic(err)
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				panic(err)
			}
			return
		}

		for _, d := range data {
			if err := t.Execute(w, d); err != nil {
				panic(err)
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				panic(err)
			}
		}
	}
}

func main() {
	const dstFile = "../../../gen_strategies.go"

	defer func() {
		if r := recover(); r != nil {
			defer panic(r)
			os.Remove(dstFile)
			return
		}
	}()

	f, err := os.Create(dstFile)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			v := any(err)
			if r := recover(); r != nil {
				v = r
			}
			panic(v)
		}
	}()

	var buf bytes.Buffer

	_, err = buf.WriteString(`// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.` + "\n\n")
	if err != nil {
		panic(err)
	}

	// create imports section of source code
	{
		render := renderer[any](&buf)

		render(parse(tsImports), nil)
	}

	// render prepareRow strategies
	{
		t := parse(tsPrepareRow)

		type cfg struct {
			Struct                 string
			NameSuffix             string
			RecBufAppend0          string
			RecBufAppend1          string
			DeltaCommentBytesCheck string
			CommentLinesCheck      string
			IncRecordIndex         string
			SetFieldStart          string
			NotQuotePossible       bool
		}

		render := renderer[cfg](&buf)

		const quoteOnSetFieldStart = "r.fieldStart = len(r.recordBuf)"

		render(t, []cfg{
			{
				Struct:         "fastReader",
				RecBufAppend0:  "r.recordBuf = append(r.recordBuf, ",
				RecBufAppend1:  "...)",
				IncRecordIndex: "r.recordIndex++",
				SetFieldStart:  quoteOnSetFieldStart,
			},
			{
				Struct:                 "secOpReader",
				NameSuffix:             "_memclearOn",
				RecBufAppend0:          "if r.appendRecBuf(",
				RecBufAppend1:          ") {return false}",
				IncRecordIndex:         "r.incRecordIndex()",
				DeltaCommentBytesCheck: "if r.outOfCommentBytes(delta) {return false}",
				CommentLinesCheck:      "if r.outOfCommentLines() {return false}",
				SetFieldStart:          quoteOnSetFieldStart,
			},
		})
	}

	// render write strategies
	{
		t := parse(tsWrite)

		type cfg struct {
			Memclear bool
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{false},
			{true},
		})
	}

	// render rune set strategies
	{
		t := parse(tsRuneSet)

		type cfg struct {
			MultiByteSize uint8
			UsageType     string
			UsageStruct   string
			Names         []string
			ArgTypes      []string
		}

		names := []string{"", "RuneLen"}
		argTypes := []string{
			"Bytes",
			"String",
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{4, "writing", "Writer", names, argTypes},
			{6, "reading", "Reader", names, argTypes},
		})
	}

	// render record writer strategies
	{
		t := parse(tsRecordWriter)

		type methodCfg struct {
			ArgType string
		}

		type cfg struct {
			Memclear bool
			Methods  []methodCfg
		}

		methods := []methodCfg{
			{"Bytes"},
			{"String"},
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{false, methods},
			{true, methods},
		})
	}

	// render write buffer strategies
	{
		t := parse(tsWriteBuffer)

		type methodCfg struct {
			ArgType string
		}

		type cfg struct {
			Memclear bool
			Methods  []methodCfg
		}

		methods := []methodCfg{
			{"Bytes"},
			{"String"},
		}

		render := renderer[cfg](&buf)

		render(t, []cfg{
			{false, methods},
			{true, methods},
		})
	}

	b := buf.Bytes()

	//
	// comment out the next block if you are trying to debug
	//

	b, err = format.Source(b) // uses standard SDK "go/format" lib
	if err != nil {
		panic(err)
	}

	_, err = f.Write(b)
	if err != nil {
		panic(err)
	}
}
