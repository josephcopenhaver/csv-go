{{if eq .MultiByteSize 4}}
//
// runeSetBase contains common behavior utilized by runeSet4 and runeSet6
//

type runeSetBase struct {
	mbRuneCount uint8
	singleBytes [8]uint32
	mbByteEnds  [2]uint32
}

// addByte assumes that the byte is a valid Unicode value less than 128
//
// any change to this function likely needs to be replicated to addRuneUniqueUnchecked()
func (rs *runeSetBase) addByte(b byte) {
	rs.singleBytes[b>>5] |= (uint32(1) << (b & 31))
}

// containsSingleByteRune would normally only work correctly when the input byte is less than utf8.RuneSelf
// however the bit set is wide enough to support all 256 bits - consuming 16 bytes more of memory to avoid
// an if-check and a bit-mask (to ensure bounds check elimination kicks in) which has shown to be definitely
// faster.
func (rs *runeSetBase) containsSingleByteRune(b byte) bool {
	return (rs.singleBytes[b>>5] & (uint32(1) << (b & 31))) != 0
}

// internalContainsMBEndByte works with either the last byte of a utf8 encoded multi-byte rune
// or the 8 least significant bits of a rune since it only cares about the lower 6 bits
// and the first two bits are guaranteed to be `10` or noise by the nature of the calling context.
func (rs *runeSetBase) internalContainsMBEndByte(b byte) bool {
	return (rs.mbByteEnds[(b>>5)&1] & (uint32(1) << (b & 31))) != 0
}
{{end}}

//
// NOTE: non-generated contents relevant to runeSet{{.MultiByteSize}} are present in fast_csv_rune_set.go
//

// runeSet{{.MultiByteSize}} is useful for csv {{.UsageType}} as the {{.UsageStruct}} will only have up to {{.MultiByteSize}} multi-byte runes ever in config.
//
// The {{.MultiByteSize}} suffix indicates that at most {{.MultiByteSize}} multi-byte runes are supported by the algorithms within this struct
// which is done for efficiency reasons.
//
// invariants:
// - utilizing context maintains that there will never be more than {{.MultiByteSize}} multi-byte runes placed in the set
type runeSet{{.MultiByteSize}} struct {
	runeSetBase
	mbRunes     [{{.MultiByteSize}}]rune
}

// addRune assumes that the rune is a valid Unicode value
func (rs *runeSet{{.MultiByteSize}}) addRune(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.addMBRune(r)
}

// internalContainsMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
func (rs *runeSet{{.MultiByteSize}}) internalContainsMBRune(r rune) bool {

	// unwound the loop search to avoid loop overhead
	//
	// becomes a fast series of opcodes when compiled
	//
	// it is end-state equivalent to the following:
	//
	//
	// for i := range rs.mbRuneCount {
	// 	if rs.mbRunes[i] == r {
	// 		return true
	// 	}
	// }
	//
	// return false

	switch rs.mbRuneCount {
    {{if ge .MultiByteSize 6 -}}
	case 6:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r || rs.mbRunes[4] == r || rs.mbRunes[5] == r)
	case 5:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r || rs.mbRunes[4] == r)
    {{end -}}
	case 4:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r)
	case 3:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r)
	case 2:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r)
	case 1:
		return (rs.mbRunes[0] == r)
	}

	return false
}

func (rs *runeSet{{.MultiByteSize}}) containsMBRune(r rune) bool {
	fastEndCheckOK := ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds[(byte(r)>>5)&1] & (uint32(1) << (r & 31))) != 0)
	return fastEndCheckOK && rs.internalContainsMBRune(r)
}

// addMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
//
// any change to this function likely needs to be replicated to addRuneUniqueUnchecked()
func (rs *runeSet{{.MultiByteSize}}) addMBRune(r rune) {
	if rs.internalContainsMBRune(r) {
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds[(byte(r)>>5)&1] |= (uint32(1) << (r & 31))
}

// internalContainsRune assumes that the rune is a valid Unicode value
func (rs *runeSet{{.MultiByteSize}}) internalContainsRune(r rune) bool {
	if r < utf8.RuneSelf {
		return ( /* inlined call to containsSingleByteRune: */ (rs.singleBytes[byte(r)>>5] & (uint32(1) << (r & 31))) != 0)
	}

	return rs.internalContainsMBRune(r)
}

// addRuneUniqueUnchecked assumes that the rune is a valid Unicode value that (if it is multi-byte when encoded) has not already been added before
//
// any change to this function likely needs to be replicated to addMBRune() or addByte()
func (rs *runeSet{{.MultiByteSize}}) addRuneUniqueUnchecked(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds[(byte(r)>>5)&1] |= (uint32(1) << (r & 31))
}

{{range .Methods}}
func (rs *runeSet{{$.MultiByteSize}}) indexAny{{.Name}}In{{.ArgType}}({{if eq .ArgType "Bytes"}}p []byte{{else}}s string{{end}}) {{.Returns}} {
	if rs.mbRuneCount == 0 {
		{{if eq .ArgType "Bytes"}}
		for i, b := range p {
		{{- else -}}
		for i := range len(s) {
			b := s[i]
		{{- end}}
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>5] & (uint32(1) << (b & 31))) != 0 {
				return {{if eq .Name "RuneLen"}}rune(b), 1, {{end}}i
			}
		}

		return {{if eq .Name "RuneLen"}}0, 0, {{end}}-1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	{{if eq .ArgType "Bytes" -}}
	for i, b := range p {
	{{- else -}}
	for i := range len(s) {
		b := s[i]
	{{- end}}

		if b < utf8.RuneSelf {
			// matched ascii character

			if ( /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>5] & (uint32(1) << (b & 31))) != 0) {
				return {{if eq .Name "RuneLen"}}rune(b), 1, {{end}}i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds[(b>>5)&1] & (uint32(1) << (b & 31))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				{{- if eq .Name "RuneLen"}}
				var n uint8
				{{- end}}
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := {{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-3], {{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune({{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-1]&0x3F)<<6 | rune(b&0x3F))
					{{- if eq .Name "RuneLen"}}
					n = 4
					{{- end}}
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := {{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-2], {{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
					{{- if eq .Name "RuneLen"}}
					n = 3
					{{- end}}
				case 1:

					// assemble the full 2-byte rune value

					r = rune({{if eq .ArgType "Bytes"}}p{{else}}s{{end}}[i-1]&0x1F)<<6 | rune(b&0x3F)
					{{- if eq .Name "RuneLen"}}
					n = 2
					{{- end}}
				}

				if rs.internalContainsMBRune(r) {
					return {{if eq .Name "RuneLen"}}r, n, {{end}}lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return {{if eq .Name "RuneLen"}}0, 0, {{end}}-1
}
{{end}}

{{if ge .MultiByteSize 6 -}}
const len8LeadingOnesTab = "" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02" +
	"\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02" +
	"\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03" +
	"\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x07\x08"

// leadingOnes8 returns the number of leading one bits in x; the result is 0 for x == 0 and 8 for 255.
func leadingOnes8(b byte) uint8 {
	return len8LeadingOnesTab[b]
}
{{end}}
