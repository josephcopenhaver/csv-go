{{ $memClear := "" }}
{{ $appendBytesRec0 := "" }}
{{ $appendStrRec0 := "" }}
{{ $appendRec1 := "" }}
{{ $setRec0 := "" }}
{{ $setRec1 := "" }}

{{if .Memclear}}
{{ $memClear = "n"}}
{{ $appendBytesRec0 = "wb.appendRec(" }}
{{ $appendStrRec0 = "wb.appendStrRec(" }}
{{ $appendRec1 = ")" }}
{{ $setRec0 = "wb.setRecordBuf(" }}
{{ $setRec1 = ")" }}

{{else}}
{{ $memClear = "ff" }}
{{ $appendBytesRec0 = "wb.recordBuf = append(wb.recordBuf, " }}
{{ $appendStrRec0 = $appendBytesRec0 }}
{{ $appendRec1 = "...)" }}
{{ $setRec0 = "wb.recordBuf = " }}

{{end}}


{{range .Methods}}
{{ $appendRec0 := "" }}
{{ $arg := "" }}
{{ $params := "" }}
{{ $loadQF := "" }}

{{if eq .ArgType "String"}}
{{ $appendRec0 = $appendStrRec0 }}
{{ $arg = "s" }}
{{ $params = printf "%s string" $arg }}
{{ $loadQF = "loadStrQF" }}

{{else}}
{{ $appendRec0 = $appendBytesRec0 }}
{{ $arg = "p" }}
{{ $params = printf "%s []byte" $arg }}
{{ $loadQF = "loadQF" }}

{{end}}
// {{$loadQF}}_memclearO{{$memClear}} is called after a
// quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and communicate to this function where to
// start scanning in the source for characters to escape. The parent context will not write any part of
// the source to the record staging zone.
//
// Essentially the function picks up after the parent context starts a quoting process which the parent
// will also complete.
func (wb *writeBuffer) {{$loadQF}}_memclearO{{$memClear}}({{$params}}, scanIdx int) {
	r, n, i := wb.escapeControlRuneSet.indexAnyRuneLenIn{{.ArgType}}({{$arg}}[scanIdx:])
	if i == -1 {
		{{$appendRec0}}{{$arg}}{{$appendRec1}}
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	{{$appendRec0}}{{$arg}}[:scanIdx]{{$appendRec1}}

	for {
		scanIdx += int(n)

		if wb.quote == r {
			{{$setRec0}}wb.escapedQuoteSeq.appendText(wb.recordBuf){{$setRec1}}
		} else {
			{{$setRec0}}wb.escapedEscapeSeq.appendText(wb.recordBuf){{$setRec1}}
		}

		r, n, i = wb.escapeControlRuneSet.indexAnyRuneLenIn{{.ArgType}}({{$arg}}[scanIdx:])
		if i == -1 {
			{{$appendRec0}}{{$arg}}[scanIdx:]{{$appendRec1}}
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		{{$appendRec0}}{{$arg}}[prevIdx:scanIdx]{{$appendRec1}}
	}
}

// {{$loadQF}}WithCheckUTF8_memclearO{{$memClear}} performs the same duties as {{$loadQF}}_memclearO{{$memClear}} and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (wb *writeBuffer) {{$loadQF}}WithCheckUTF8_memclearO{{$memClear}}({{$params}}, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len({{$arg}}) {
			{{$appendRec0}}{{$arg}}[loadIdx:]{{$appendRec1}}
			return nil
		}

		if b := {{$arg}}[scanIdx]; b < utf8.RuneSelf {
			if !wb.escapeControlRuneSet.containsSingleByteRune(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRune{{if eq "String" .ArgType}}InString{{end}}({{$arg}}[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !wb.escapeControlRuneSet.containsMBRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		{{$appendRec0}}{{$arg}}[loadIdx:scanIdx]{{$appendRec1}}

		scanIdx += n
		loadIdx = scanIdx

		if wb.quote == r {
			{{$setRec0}}wb.escapedQuoteSeq.appendText(wb.recordBuf){{$setRec1}}
			continue
		}

		{{$setRec0}}wb.escapedEscapeSeq.appendText(wb.recordBuf){{$setRec1}}
	}
}
{{end}}
