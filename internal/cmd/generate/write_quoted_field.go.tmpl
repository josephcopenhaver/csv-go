{{- define "appendRec0"}}{{if .Memclear}}w.appendRec({{else}}w.recordBuf = append(w.recordBuf, {{end}}{{end}}
{{define "appendRec1"}}{{if .Memclear}}){{else}}...){{end}}{{end -}}

// loadQF_memclearO{{if .Memclear}}n{{else}}ff{{end}} is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadQF_memclearO{{if .Memclear}}n{{else}}ff{{end}}(src []byte, loadIdx, scanIdx int) {
	// escape any quote or escape runes found
	for {
		i := bytes.IndexAny(src[scanIdx:], w.escapeControlRunes)
		if i == -1 {
			{{template "appendRec0" .}}src[loadIdx:]{{template "appendRec1" .}}
			return
		}
		i += scanIdx

		{{template "appendRec0" .}}src[loadIdx:i]{{template "appendRec1" .}}

		r, n := utf8.DecodeRune(src[i:])
		scanIdx = i+n
		loadIdx = scanIdx

		if w.quote == r {
			{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
			continue
		}

		{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
	}
}

// loadQFWithCheckUTF8_memclearO{{if .Memclear}}n{{else}}ff{{end}} performs the same duties as loadQField_memclearO{{if .Memclear}}n{{else}}ff{{end}} and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadQFWithCheckUTF8_memclearO{{if .Memclear}}n{{else}}ff{{end}}(src []byte, loadIdx, scanIdx int) error {
	for {
		r, n := utf8.DecodeRune(src[scanIdx:])
		if n == 0 {
			// all good and no overlap issues, so just directly copy src
			{{template "appendRec0" .}}src[loadIdx:]{{template "appendRec1" .}}
			return nil
		}
		if n == 1 && r == utf8.RuneError {
			return ErrNonUTF8InRecord
		}

		if !strings.ContainsRune(w.escapeControlRunes, r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind
		//

		{{template "appendRec0" .}}src[loadIdx:scanIdx]{{template "appendRec1" .}}

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			{{template "appendRec0" .}}w.escapedQuote[:w.escapedQuoteByteLen]{{template "appendRec1" .}}
			continue
		}

		{{template "appendRec0" .}}w.escapedEscape[:w.escapedEscapeByteLen]{{template "appendRec1" .}}
	}
}
