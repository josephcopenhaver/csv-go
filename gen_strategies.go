// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.

package csv

import (
	"bytes"
	"errors"
	"io"
	"unicode/utf8"
	"unsafe"
)

func (r *fastReader) prepareRow() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c&asciiBitMask == 0 {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			di := bytes.IndexAny(r.rawBuf[r.rawIndex:], r.controlRunes)
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			c := rune(r.rawBuf[idx])
			size := uint8(1)
			if (c & asciiBitMask) != 0 {
				c, size = decodeMBControlRune(r.rawBuf[idx:])
			}

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSep[0]:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.recordIndex++
						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++
						r.fieldIndex = 0
						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++
						r.fieldIndex = 0
						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSep[0] = asciiCarriageReturn
						r.recordSep[1] = asciiLineFeed
					} else {
						r.recordSepRuneLen = 1
						r.recordSep[0] = c
					}

					// preserve field separator
					var buf [7]rune
					controlRunes := append(buf[:0], r.fieldSeparator)
					controlRunes = append(controlRunes, c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRunes = append(controlRunes, r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRunes = append(controlRunes, r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRunes = append(controlRunes, r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						crs := []byte(string(controlRunes))

						if !bytes.Contains(crs, []byte{asciiCarriageReturn}) {
							controlRunes = append(controlRunes, asciiCarriageReturn)
						}

						if !bytes.Contains(crs, []byte{asciiLineFeed}) {
							controlRunes = append(controlRunes, asciiLineFeed)
						}
					}

					r.controlRunes = string(controlRunes)

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (r *secOpReader) prepareRow_memclearOn() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c&asciiBitMask == 0 {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			di := bytes.IndexAny(r.rawBuf[r.rawIndex:], r.controlRunes)
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]...) {
						return false
					}

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]...) {
						return false
					}

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex
					if r.outOfCommentBytes(delta) {
						return false
					}

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			c := rune(r.rawBuf[idx])
			size := uint8(1)
			if (c & asciiBitMask) != 0 {
				c, size = decodeMBControlRune(r.rawBuf[idx:])
			}

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSep[0]:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]...) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]...) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							if r.outOfCommentLines() {
								return false
							}

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.incRecordIndex()
						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()
						r.fieldIndex = 0
						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()
						r.fieldIndex = 0
						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						if r.outOfCommentLines() {
							return false
						}

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)
						if r.outOfCommentBytes(delta) {
							return false
						}

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSep[0] = asciiCarriageReturn
						r.recordSep[1] = asciiLineFeed
					} else {
						r.recordSepRuneLen = 1
						r.recordSep[0] = c
					}

					// preserve field separator
					var buf [7]rune
					controlRunes := append(buf[:0], r.fieldSeparator)
					controlRunes = append(controlRunes, c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRunes = append(controlRunes, r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRunes = append(controlRunes, r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRunes = append(controlRunes, r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						crs := []byte(string(controlRunes))

						if !bytes.Contains(crs, []byte{asciiCarriageReturn}) {
							controlRunes = append(controlRunes, asciiCarriageReturn)
						}

						if !bytes.Contains(crs, []byte{asciiLineFeed}) {
							controlRunes = append(controlRunes, asciiLineFeed)
						}
					}

					r.controlRunes = string(controlRunes)

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]...) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (w *Writer) processField_escapeOff_forceQuoteOff_memclearOff(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeOff_memclearOff(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeOn_forceQuoteOff_memclearOff(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		case w.escape:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeOn_memclearOff(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeOff_forceQuoteOn_memclearOff(v []byte) (int, error) {

	n, err := w.escapeChars_escapeOff_memclearOff(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeOn_forceQuoteOn_memclearOff(v []byte) (int, error) {

	n, err := w.escapeChars_escapeOn_memclearOff(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeOff_forceQuoteOff_memclearOn(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeOff_memclearOn(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeOn_forceQuoteOff_memclearOn(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		case w.escape:
			w.appendField(v[:i], w.escapedEscape[:w.escapedEscapeByteLen])

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeOn_memclearOn(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeOff_forceQuoteOn_memclearOn(v []byte) (int, error) {

	n, err := w.escapeChars_escapeOff_memclearOn(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeOn_forceQuoteOn_memclearOn(v []byte) (int, error) {

	n, err := w.escapeChars_escapeOn_memclearOn(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) escapeChars_escapeOff_memclearOff(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeOn_memclearOff(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		case w.escape:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeOff_memclearOn(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[si:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeOn_memclearOn(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[si:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		case w.escape:
			w.appendField(v[si:i], w.escapedEscape[:w.escapedEscapeByteLen])

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) writeRow_memclearOff(row []string) (int, error) {
	if len(row) == 1 && row[0] == "" {
		// This is a safety feature that makes the document slightly more durable to being edited.
		// If we could guarantee that the "record terminator" is never removed by accident via
		// "whitespace removal" of editors then this is extra work with no benefit. If this ever
		// becomes disable-allowed then I would still default it to enabled behavior.

		// note that this creates quite a bit of extra characters at times
		// ideally only the last row would have this escaping as most parsers
		// would understand the rows in-between as empty-value cells
		//
		// doing this would require that we buffer the last written line
		// and either add a close or flush function we expect persons to call
		//
		// but then again this only affects tables where there is one and only one attribute that is often an empty string
		//
		// seems like an odd path to optimize for, but we could
		w.writeDoubleQuotesForRecord()
	} else {
		if err := w.writeField_memclearOff(w.processFirstField, row[0]); err != nil {
			return 0, err
		}

		for _, v := range row[1:] {

			// write field separator
			w.recordBuf = append(w.recordBuf, []byte(string(w.fieldSep))...)

			if err := w.writeField_memclearOff(w.processField, v); err != nil {
				return 0, err
			}
		}
	}

	w.recordBuf = append(w.recordBuf, w.recordSepBytes[:w.recordSepByteLen]...)

	w.recordWritten = true
	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err := writeIOErr{err}
		w.setErr(err)
		return n, err
	}

	return n, nil
}

func (w *Writer) writeDoubleQuotesForRecord_memclearOff() {
	w.recordBuf = append(w.recordBuf, w.twoQuotes[:w.twoQuotesByteLen]...)
}

func (w *Writer) writeField_memclearOff(processField func([]byte) (int, error), input string) error {
	if input == "" {
		return nil
	}
	defer func() {
		w.fieldBuf = w.fieldBuf[:0]
	}()

	// v here is immutable
	//
	// unsafe may look concerning and scary, and it can be,
	// however in this case we're never writing to the slice
	// created here which is stored within `v`
	//
	// since strings are immutable as well this is actually a safe
	// usage of the unsafe package to avoid an allocation we're
	// just going to read from and then throw away before this
	// returns
	//
	// It will also never be called if the len is zero,
	// just as an extra precaution.
	v := unsafe.Slice(unsafe.StringData(input), len(input))

	si, err := processField(v)
	if err != nil {

		return err
	} else if si == -1 {
		// w.fieldBuf is guaranteed to be empty on this code path
		//
		// use v instead
		w.recordBuf = append(w.recordBuf, v...)

		return nil
	}

	// w.fieldBuf might have a len greater than zero on this code path
	// if it does then use it

	w.recordBuf = append(w.recordBuf, []byte(string(w.quote))...)
	if len(w.fieldBuf) > 0 {
		w.recordBuf = append(w.recordBuf, w.fieldBuf...)
		w.recordBuf = append(w.recordBuf, v[si:]...)

	} else {
		w.recordBuf = append(w.recordBuf, v...)
	}
	w.recordBuf = append(w.recordBuf, []byte(string(w.quote))...)

	return nil
}

func (w *Writer) writeRow_memclearOn(row []string) (int, error) {
	if len(row) == 1 && row[0] == "" {
		// This is a safety feature that makes the document slightly more durable to being edited.
		// If we could guarantee that the "record terminator" is never removed by accident via
		// "whitespace removal" of editors then this is extra work with no benefit. If this ever
		// becomes disable-allowed then I would still default it to enabled behavior.

		// note that this creates quite a bit of extra characters at times
		// ideally only the last row would have this escaping as most parsers
		// would understand the rows in-between as empty-value cells
		//
		// doing this would require that we buffer the last written line
		// and either add a close or flush function we expect persons to call
		//
		// but then again this only affects tables where there is one and only one attribute that is often an empty string
		//
		// seems like an odd path to optimize for, but we could
		w.writeDoubleQuotesForRecord()
	} else {
		if err := w.writeField_memclearOn(w.processFirstField, row[0]); err != nil {
			return 0, err
		}

		for _, v := range row[1:] {

			// write field separator
			w.appendRec([]byte(string(w.fieldSep)))

			if err := w.writeField_memclearOn(w.processField, v); err != nil {
				return 0, err
			}
		}
	}

	w.appendRec(w.recordSepBytes[:w.recordSepByteLen])

	w.recordWritten = true
	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err := writeIOErr{err}
		w.setErr(err)
		return n, err
	}

	return n, nil
}

func (w *Writer) writeDoubleQuotesForRecord_memclearOn() {
	w.appendRec(w.twoQuotes[:w.twoQuotesByteLen])
}

func (w *Writer) writeField_memclearOn(processField func([]byte) (int, error), input string) error {
	if input == "" {
		return nil
	}
	defer func() {
		w.fieldBuf = w.fieldBuf[:0]
	}()

	// v here is immutable
	//
	// unsafe may look concerning and scary, and it can be,
	// however in this case we're never writing to the slice
	// created here which is stored within `v`
	//
	// since strings are immutable as well this is actually a safe
	// usage of the unsafe package to avoid an allocation we're
	// just going to read from and then throw away before this
	// returns
	//
	// It will also never be called if the len is zero,
	// just as an extra precaution.
	v := unsafe.Slice(unsafe.StringData(input), len(input))

	si, err := processField(v)
	if err != nil {

		return err
	} else if si == -1 {
		// w.fieldBuf is guaranteed to be empty on this code path
		//
		// use v instead
		w.appendRec(v)

		return nil
	}

	// w.fieldBuf might have a len greater than zero on this code path
	// if it does then use it

	w.appendRec([]byte(string(w.quote)))
	if len(w.fieldBuf) > 0 {
		w.appendRec(w.fieldBuf, v[si:])

	} else {
		w.appendRec(v)
	}
	w.appendRec([]byte(string(w.quote)))

	return nil
}
