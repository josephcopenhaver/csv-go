// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.

package csv

import (
	"errors"
	"io"
	"unicode/utf8"
	"unsafe"
)

func (r *fastReader) prepareRow() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c < utf8.RuneSelf {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			c, size, di := r.controlRuneScape.indexAnyRuneLenInBytes(r.rawBuf[r.rawIndex:])
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSepStartRune:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.recordIndex++

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSepStartRune = asciiCarriageReturn
					} else {
						r.recordSepRuneLen = 1
						r.recordSepStartRune = c
					}

					// preserve field separator
					var controlRuneScape runeScape6
					controlRuneScape.addRuneUniqueUnchecked(r.fieldSeparator)
					controlRuneScape.addRuneUniqueUnchecked(c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						controlRuneScape.addByte(asciiCarriageReturn)
						controlRuneScape.addByte(asciiLineFeed)
					}

					r.controlRuneScape = controlRuneScape

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (r *secOpReader) prepareRow_memclearOn() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c < utf8.RuneSelf {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			c, size, di := r.controlRuneScape.indexAnyRuneLenInBytes(r.rawBuf[r.rawIndex:])
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex
					if r.outOfCommentBytes(delta) {
						return false
					}

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSepStartRune:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							if r.outOfCommentLines() {
								return false
							}

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						if r.outOfCommentLines() {
							return false
						}

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)
						if r.outOfCommentBytes(delta) {
							return false
						}

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSepStartRune = asciiCarriageReturn
					} else {
						r.recordSepRuneLen = 1
						r.recordSepStartRune = c
					}

					// preserve field separator
					var controlRuneScape runeScape6
					controlRuneScape.addRuneUniqueUnchecked(r.fieldSeparator)
					controlRuneScape.addRuneUniqueUnchecked(c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRuneScape.addRuneUniqueUnchecked(r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						controlRuneScape.addByte(asciiCarriageReturn)
						controlRuneScape.addByte(asciiLineFeed)
					}

					r.controlRuneScape = controlRuneScape

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (w *Writer) writeRow_memclearOff(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
					w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
					w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.recordBuf = src
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneScape.indexAnyInBytes(src)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, src...)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadQF_memclearOff(src, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(src) {
					w.recordBuf = append(w.recordBuf, src...)
					goto FIRST_FIELD_WRITTEN
				}

				b := src[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneScape.containsByte(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneScape.containsWideRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

		err = w.loadQFWithCheckUTF8_memclearOff(src, i)
		if err != nil {
			return 0, err
		}

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.recordBuf = w.fieldSepSeq.appendText(w.recordBuf)

		f := &fields[i]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.recordBuf = src
				continue
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneScape.indexAnyInBytes(src)
			if i == -1 {
				w.recordBuf = append(w.recordBuf, src...)
				continue
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadQF_memclearOff(src, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(src) {
				w.recordBuf = append(w.recordBuf, src...)
				break
			}
			if b := src[i]; b < utf8.RuneSelf {
				if !w.controlRuneScape.containsByte(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneScape.containsWideRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind
			//

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			err = w.loadQFWithCheckUTF8_memclearOff(src, i)
			if err != nil {
				return 0, err
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			break
		}
	}

	w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

// loadQF_memclearOff is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadQF_memclearOff(src []byte, scanIdx int) {
	r, n, i := w.escapeControlRuneScape.indexAnyRuneLenInBytes(src[scanIdx:])
	if i == -1 {
		w.recordBuf = append(w.recordBuf, src...)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	w.recordBuf = append(w.recordBuf, src[:scanIdx]...)

	for {
		scanIdx += int(n)

		if w.quote == r {
			w.recordBuf = w.escapedQuoteSeq.appendText(w.recordBuf)
		} else {
			w.recordBuf = w.escapedEscapeSeq.appendText(w.recordBuf)
		}

		r, n, i = w.escapeControlRuneScape.indexAnyRuneLenInBytes(src[scanIdx:])
		if i == -1 {
			w.recordBuf = append(w.recordBuf, src[scanIdx:]...)
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		w.recordBuf = append(w.recordBuf, src[prevIdx:scanIdx]...)
	}
}

// loadQFWithCheckUTF8_memclearOff performs the same duties as loadQField_memclearOff and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadQFWithCheckUTF8_memclearOff(src []byte, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(src) {
			w.recordBuf = append(w.recordBuf, src[loadIdx:]...)
			return nil
		}

		if b := src[scanIdx]; b < utf8.RuneSelf {
			if !w.escapeControlRuneScape.containsByte(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRune(src[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !w.escapeControlRuneScape.containsWideRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		w.recordBuf = append(w.recordBuf, src[loadIdx:scanIdx]...)

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.recordBuf = w.escapedQuoteSeq.appendText(w.recordBuf)
			continue
		}

		w.recordBuf = w.escapedEscapeSeq.appendText(w.recordBuf)
	}
}

func (w *Writer) writeStrRow_memclearOff(fields []string) (int, error) {
	// write the first field
	{
		s := fields[0]
		if len(s) == 0 {
			if len(fields) == 1 {
				w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
				w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

				n, err := w.writer.Write(w.recordBuf)
				if err != nil {
					err = writeIOErr{err}
				}
				return n, err
			}
			goto FIRST_FIELD_WRITTEN
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneScape.indexAnyInString(s)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, s...)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadStrQF_memclearOff(s, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(s) {
					w.recordBuf = append(w.recordBuf, s...)
					goto FIRST_FIELD_WRITTEN
				}

				b := s[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneScape.containsByte(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneScape.containsWideRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

		if err := w.loadStrQFWithCheckUTF8_memclearOff(s, i); err != nil {
			return 0, err
		}

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.recordBuf = w.fieldSepSeq.appendText(w.recordBuf)

		s := fields[i]
		if len(s) == 0 {
			continue
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneScape.indexAnyInString(s)
			if i == -1 {
				w.recordBuf = append(w.recordBuf, s...)
				continue
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadStrQF_memclearOff(s, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(s) {
				w.recordBuf = append(w.recordBuf, s...)
				break
			}

			if b := s[i]; b < utf8.RuneSelf {
				if !w.controlRuneScape.containsByte(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneScape.containsWideRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			if err := w.loadStrQFWithCheckUTF8_memclearOff(s, i); err != nil {
				return 0, err
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			break
		}
	}

	w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

// loadStrQF_memclearOff operates on strings and is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadStrQF_memclearOff(s string, scanIdx int) {
	r, n, i := w.escapeControlRuneScape.indexAnyRuneLenInString(s[scanIdx:])
	if i == -1 {
		w.recordBuf = append(w.recordBuf, s...)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	w.recordBuf = append(w.recordBuf, s[:scanIdx]...)

	for {
		scanIdx += int(n)

		if w.quote == r {
			w.recordBuf = w.escapedQuoteSeq.appendText(w.recordBuf)
		} else {
			w.recordBuf = w.escapedEscapeSeq.appendText(w.recordBuf)
		}

		r, n, i = w.escapeControlRuneScape.indexAnyRuneLenInString(s[scanIdx:])
		if i == -1 {
			w.recordBuf = append(w.recordBuf, s[scanIdx:]...)
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		w.recordBuf = append(w.recordBuf, s[prevIdx:scanIdx]...)
	}
}

// loadStrQFWithCheckUTF8_memclearOff performs the same duties as loadQField_memclearOff but with strings and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadStrQFWithCheckUTF8_memclearOff(s string, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(s) {
			w.recordBuf = append(w.recordBuf, s[loadIdx:]...)
			return nil
		}

		if b := s[scanIdx]; b < utf8.RuneSelf {
			if !w.escapeControlRuneScape.containsByte(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRuneInString(s[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !w.escapeControlRuneScape.containsWideRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		w.recordBuf = append(w.recordBuf, s[loadIdx:scanIdx]...)

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.recordBuf = w.escapedQuoteSeq.appendText(w.recordBuf)
			continue
		}

		w.recordBuf = w.escapedEscapeSeq.appendText(w.recordBuf)
	}
}

func (w *Writer) writeRow_memclearOn(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
					w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
					w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.setRecordBuf(src)
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneScape.indexAnyInBytes(src)
				if i == -1 {
					w.appendRec(src)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadQF_memclearOn(src, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(src) {
					w.appendRec(src)
					goto FIRST_FIELD_WRITTEN
				}

				b := src[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneScape.containsByte(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneScape.containsWideRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

		err = w.loadQFWithCheckUTF8_memclearOn(src, i)
		if err != nil {
			return 0, err
		}

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.setRecordBuf(w.fieldSepSeq.appendText(w.recordBuf))

		f := &fields[i]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.setRecordBuf(src)
				continue
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneScape.indexAnyInBytes(src)
			if i == -1 {
				w.appendRec(src)
				continue
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadQF_memclearOn(src, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(src) {
				w.appendRec(src)
				break
			}
			if b := src[i]; b < utf8.RuneSelf {
				if !w.controlRuneScape.containsByte(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneScape.containsWideRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind
			//

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			err = w.loadQFWithCheckUTF8_memclearOn(src, i)
			if err != nil {
				return 0, err
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			break
		}
	}

	w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

// loadQF_memclearOn is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadQF_memclearOn(src []byte, scanIdx int) {
	r, n, i := w.escapeControlRuneScape.indexAnyRuneLenInBytes(src[scanIdx:])
	if i == -1 {
		w.appendRec(src)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	w.appendRec(src[:scanIdx])

	for {
		scanIdx += int(n)

		if w.quote == r {
			w.setRecordBuf(w.escapedQuoteSeq.appendText(w.recordBuf))
		} else {
			w.setRecordBuf(w.escapedEscapeSeq.appendText(w.recordBuf))
		}

		r, n, i = w.escapeControlRuneScape.indexAnyRuneLenInBytes(src[scanIdx:])
		if i == -1 {
			w.appendRec(src[scanIdx:])
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		w.appendRec(src[prevIdx:scanIdx])
	}
}

// loadQFWithCheckUTF8_memclearOn performs the same duties as loadQField_memclearOn and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadQFWithCheckUTF8_memclearOn(src []byte, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(src) {
			w.appendRec(src[loadIdx:])
			return nil
		}

		if b := src[scanIdx]; b < utf8.RuneSelf {
			if !w.escapeControlRuneScape.containsByte(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRune(src[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !w.escapeControlRuneScape.containsWideRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		w.appendRec(src[loadIdx:scanIdx])

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.setRecordBuf(w.escapedQuoteSeq.appendText(w.recordBuf))
			continue
		}

		w.setRecordBuf(w.escapedEscapeSeq.appendText(w.recordBuf))
	}
}

func (w *Writer) writeStrRow_memclearOn(fields []string) (int, error) {
	// write the first field
	{
		s := fields[0]
		if len(s) == 0 {
			if len(fields) == 1 {
				w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
				w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

				n, err := w.writer.Write(w.recordBuf)
				if err != nil {
					err = writeIOErr{err}
				}
				return n, err
			}
			goto FIRST_FIELD_WRITTEN
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneScape.indexAnyInString(s)
				if i == -1 {
					w.appendStrRec(s)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadStrQF_memclearOn(s, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(s) {
					w.appendStrRec(s)
					goto FIRST_FIELD_WRITTEN
				}

				b := s[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneScape.containsByte(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneScape.containsWideRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

		if err := w.loadStrQFWithCheckUTF8_memclearOn(s, i); err != nil {
			return 0, err
		}

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.setRecordBuf(w.fieldSepSeq.appendText(w.recordBuf))

		s := fields[i]
		if len(s) == 0 {
			continue
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneScape.indexAnyInString(s)
			if i == -1 {
				w.appendStrRec(s)
				continue
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadStrQF_memclearOn(s, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(s) {
				w.appendStrRec(s)
				break
			}

			if b := s[i]; b < utf8.RuneSelf {
				if !w.controlRuneScape.containsByte(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneScape.containsWideRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			if err := w.loadStrQFWithCheckUTF8_memclearOn(s, i); err != nil {
				return 0, err
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			break
		}
	}

	w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

// loadStrQF_memclearOn operates on strings and is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadStrQF_memclearOn(s string, scanIdx int) {
	r, n, i := w.escapeControlRuneScape.indexAnyRuneLenInString(s[scanIdx:])
	if i == -1 {
		w.appendStrRec(s)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	w.appendStrRec(s[:scanIdx])

	for {
		scanIdx += int(n)

		if w.quote == r {
			w.setRecordBuf(w.escapedQuoteSeq.appendText(w.recordBuf))
		} else {
			w.setRecordBuf(w.escapedEscapeSeq.appendText(w.recordBuf))
		}

		r, n, i = w.escapeControlRuneScape.indexAnyRuneLenInString(s[scanIdx:])
		if i == -1 {
			w.appendStrRec(s[scanIdx:])
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		w.appendStrRec(s[prevIdx:scanIdx])
	}
}

// loadStrQFWithCheckUTF8_memclearOn performs the same duties as loadQField_memclearOn but with strings and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadStrQFWithCheckUTF8_memclearOn(s string, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(s) {
			w.appendStrRec(s[loadIdx:])
			return nil
		}

		if b := s[scanIdx]; b < utf8.RuneSelf {
			if !w.escapeControlRuneScape.containsByte(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRuneInString(s[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !w.escapeControlRuneScape.containsWideRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		w.appendStrRec(s[loadIdx:scanIdx])

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.setRecordBuf(w.escapedQuoteSeq.appendText(w.recordBuf))
			continue
		}

		w.setRecordBuf(w.escapedEscapeSeq.appendText(w.recordBuf))
	}
}
