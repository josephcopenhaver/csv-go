// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.

package csv

import (
	"bytes"
	"errors"
	"io"
	"strings"
	"unicode/utf8"
	"unsafe"
)

func (r *fastReader) prepareRow() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c&asciiBitMask == 0 {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			di := bytes.IndexAny(r.rawBuf[r.rawIndex:], r.controlRunes)
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			c := rune(r.rawBuf[idx])
			size := uint8(1)
			if (c & asciiBitMask) != 0 {
				c, size = decodeMBControlRune(r.rawBuf[idx:])
			}

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSep[0]:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.recordIndex++

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSep[0] = asciiCarriageReturn
						r.recordSep[1] = asciiLineFeed
					} else {
						r.recordSepRuneLen = 1
						r.recordSep[0] = c
					}

					// preserve field separator
					var buf [7]rune
					controlRunes := append(buf[:0], r.fieldSeparator)
					controlRunes = append(controlRunes, c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRunes = append(controlRunes, r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRunes = append(controlRunes, r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRunes = append(controlRunes, r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						crs := []byte(string(controlRunes))

						if !bytes.Contains(crs, []byte{asciiCarriageReturn}) {
							controlRunes = append(controlRunes, asciiCarriageReturn)
						}

						if !bytes.Contains(crs, []byte{asciiLineFeed}) {
							controlRunes = append(controlRunes, asciiLineFeed)
						}
					}

					r.controlRunes = string(controlRunes)

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (r *secOpReader) prepareRow_memclearOn() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c&asciiBitMask == 0 {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0)
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if (r.rawBuf[len(r.rawBuf)-i] & 0xC0) == 0xC0 {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			di := bytes.IndexAny(r.rawBuf[r.rawIndex:], r.controlRunes)
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex
					if r.outOfCommentBytes(delta) {
						return false
					}

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			c := rune(r.rawBuf[idx])
			size := uint8(1)
			if (c & asciiBitMask) != 0 {
				c, size = decodeMBControlRune(r.rawBuf[idx:])
			}

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSep[0]:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							if r.outOfCommentLines() {
								return false
							}

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						if r.outOfCommentLines() {
							return false
						}

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)
						if r.outOfCommentBytes(delta) {
							return false
						}

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSep[0] = asciiCarriageReturn
						r.recordSep[1] = asciiLineFeed
					} else {
						r.recordSepRuneLen = 1
						r.recordSep[0] = c
					}

					// preserve field separator
					var buf [7]rune
					controlRunes := append(buf[:0], r.fieldSeparator)
					controlRunes = append(controlRunes, c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRunes = append(controlRunes, r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRunes = append(controlRunes, r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRunes = append(controlRunes, r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						crs := []byte(string(controlRunes))

						if !bytes.Contains(crs, []byte{asciiCarriageReturn}) {
							controlRunes = append(controlRunes, asciiCarriageReturn)
						}

						if !bytes.Contains(crs, []byte{asciiLineFeed}) {
							controlRunes = append(controlRunes, asciiLineFeed)
						}
					}

					r.controlRunes = string(controlRunes)

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (w *Writer) writeRow_memclearOff(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.recordBuf = append(w.recordBuf, w.twoQuotes[:w.twoQuotesByteLen]...)
					w.recordBuf = append(w.recordBuf, w.recordSepBytes[:w.recordSepByteLen]...)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.recordBuf = append(w.recordBuf, w.twoQuotes[:w.twoQuotesByteLen]...)
					w.recordBuf = append(w.recordBuf, w.recordSepBytes[:w.recordSepByteLen]...)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.recordBuf = src
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, src...)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

			w.loadQF_memclearOff(src, i)

			w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		i := 0
		for {
			r, n := utf8.DecodeRune(src[i:])
			if n == 0 {
				// all good and no overlap issues, so just directly copy src
				w.recordBuf = append(w.recordBuf, src...)
				break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
			}
			if n == 1 && r == utf8.RuneError {
				return 0, ErrNonUTF8InRecord
			}

			if (w.bitFlags&wFlagForceQuoteFirstField) == 0 && !strings.ContainsRune(w.controlRunes, r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

			err = w.loadQFWithCheckUTF8_memclearOff(src, i)
			if err != nil {
				return 0, err
			}

			w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

			break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
		}
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.recordBuf = append(w.recordBuf, w.fieldSepBytes[:w.fieldSepByteLen]...)

	SUBSEQUENT_FIELD_WRITE:
		for {
			f := &fields[i]

			var scanForNonUTF8 bool
			var src []byte
			var err error

			switch f.kind {
			case wfkBytes:
				src = f.bytes
				if len(src) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
			case wfkString:
				s := f.str
				if len(s) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
				src = unsafe.Slice(unsafe.StringData(s), len(s))
			case wfkRune:
				src, err = f.runeAppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}

				// src is now guaranteed to be a utf8 encoded non-empty byte sequence
				// so scanForNonUTF8 will remain false here intentionally
			default:
				if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
					src, err = f.AppendText(w.recordBuf)
					if err != nil {
						return 0, err
					}

					w.recordBuf = src
					break SUBSEQUENT_FIELD_WRITE
				}

				src, err = f.AppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}
			}

			//
			// process src buf
			//

			if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
				// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

				i := bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, src...)
					break
				}

				w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

				w.loadQF_memclearOff(src, i)

				w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

				break
			}

			// for each decoded rune, check if that rune fails to decode and if so then return an error
			// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
			// continue loading

			i := 0
			for {
				r, n := utf8.DecodeRune(src[i:])
				if n == 0 {
					// all good and no overlap issues, so just directly copy src
					w.recordBuf = append(w.recordBuf, src...)
					break
				}
				if n == 1 && r == utf8.RuneError {
					return 0, ErrNonUTF8InRecord
				}

				if !strings.ContainsRune(w.controlRunes, r) {
					i += n
					continue
				}

				//
				// found a control rune of some kind
				//

				w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

				err = w.loadQFWithCheckUTF8_memclearOff(src, i)
				if err != nil {
					return 0, err
				}

				w.recordBuf = append(w.recordBuf, w.quoteBytes[:w.quoteByteLen]...)

				break
			}

			break
		}
	}

	w.recordBuf = append(w.recordBuf, w.recordSepBytes[:w.recordSepByteLen]...)

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

func (w *Writer) writeRow_memclearOn(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.appendRec(w.twoQuotes[:w.twoQuotesByteLen])
					w.appendRec(w.recordSepBytes[:w.recordSepByteLen])

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.appendRec(w.twoQuotes[:w.twoQuotesByteLen])
					w.appendRec(w.recordSepBytes[:w.recordSepByteLen])

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.setRecordBuf(src)
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					w.appendRec(src)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.appendRec(w.quoteBytes[:w.quoteByteLen])

			w.loadQF_memclearOn(src, i)

			w.appendRec(w.quoteBytes[:w.quoteByteLen])

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		i := 0
		for {
			r, n := utf8.DecodeRune(src[i:])
			if n == 0 {
				// all good and no overlap issues, so just directly copy src
				w.appendRec(src)
				break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
			}
			if n == 1 && r == utf8.RuneError {
				return 0, ErrNonUTF8InRecord
			}

			if (w.bitFlags&wFlagForceQuoteFirstField) == 0 && !strings.ContainsRune(w.controlRunes, r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.appendRec(w.quoteBytes[:w.quoteByteLen])

			err = w.loadQFWithCheckUTF8_memclearOn(src, i)
			if err != nil {
				return 0, err
			}

			w.appendRec(w.quoteBytes[:w.quoteByteLen])

			break // same as `goto FIRST_FIELD_WRITTEN` - using break specifically to increase code coverage
		}
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.appendRec(w.fieldSepBytes[:w.fieldSepByteLen])

	SUBSEQUENT_FIELD_WRITE:
		for {
			f := &fields[i]

			var scanForNonUTF8 bool
			var src []byte
			var err error

			switch f.kind {
			case wfkBytes:
				src = f.bytes
				if len(src) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
			case wfkString:
				s := f.str
				if len(s) == 0 {
					break SUBSEQUENT_FIELD_WRITE
				}

				scanForNonUTF8 = (f._64_bits == 0)
				src = unsafe.Slice(unsafe.StringData(s), len(s))
			case wfkRune:
				src, err = f.runeAppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}

				// src is now guaranteed to be a utf8 encoded non-empty byte sequence
				// so scanForNonUTF8 will remain false here intentionally
			default:
				if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
					src, err = f.AppendText(w.recordBuf)
					if err != nil {
						return 0, err
					}

					w.setRecordBuf(src)
					break SUBSEQUENT_FIELD_WRITE
				}

				src, err = f.AppendText(w.fieldWriterBuf[:0])
				if err != nil {
					return 0, err
				}
			}

			//
			// process src buf
			//

			if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
				// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

				i := bytes.IndexAny(src, w.controlRunes)
				if i == -1 {
					w.appendRec(src)
					break
				}

				w.appendRec(w.quoteBytes[:w.quoteByteLen])

				w.loadQF_memclearOn(src, i)

				w.appendRec(w.quoteBytes[:w.quoteByteLen])

				break
			}

			// for each decoded rune, check if that rune fails to decode and if so then return an error
			// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
			// continue loading

			i := 0
			for {
				r, n := utf8.DecodeRune(src[i:])
				if n == 0 {
					// all good and no overlap issues, so just directly copy src
					w.appendRec(src)
					break
				}
				if n == 1 && r == utf8.RuneError {
					return 0, ErrNonUTF8InRecord
				}

				if !strings.ContainsRune(w.controlRunes, r) {
					i += n
					continue
				}

				//
				// found a control rune of some kind
				//

				w.appendRec(w.quoteBytes[:w.quoteByteLen])

				err = w.loadQFWithCheckUTF8_memclearOn(src, i)
				if err != nil {
					return 0, err
				}

				w.appendRec(w.quoteBytes[:w.quoteByteLen])

				break
			}

			break
		}
	}

	w.appendRec(w.recordSepBytes[:w.recordSepByteLen])

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

// loadQF_memclearOff is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadQF_memclearOff(src []byte, scanIdx int) {
	// escape any quote or escape runes found

	i := bytes.IndexAny(src[scanIdx:], w.escapeControlRunes)
	if i == -1 {
		w.recordBuf = append(w.recordBuf, src...)
		return
	}
	scanIdx += i

	w.recordBuf = append(w.recordBuf, src[:scanIdx]...)

	for {
		r, n := utf8.DecodeRune(src[scanIdx:])
		scanIdx += n

		if w.quote == r {
			w.recordBuf = append(w.recordBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)
		} else {
			w.recordBuf = append(w.recordBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)
		}

		i = bytes.IndexAny(src[scanIdx:], w.escapeControlRunes)
		if i == -1 {
			w.recordBuf = append(w.recordBuf, src[scanIdx:]...)
			return
		}

		scanIdx += i
	}
}

// loadQFWithCheckUTF8_memclearOff performs the same duties as loadQField_memclearOff and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadQFWithCheckUTF8_memclearOff(src []byte, scanIdx int) error {
	var loadIdx int
	for {
		r, n := utf8.DecodeRune(src[scanIdx:])
		if n == 0 {
			// all good and no overlap issues, so just directly copy src
			w.recordBuf = append(w.recordBuf, src[loadIdx:]...)
			return nil
		}
		if n == 1 && r == utf8.RuneError {
			return ErrNonUTF8InRecord
		}

		if !strings.ContainsRune(w.escapeControlRunes, r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind
		//

		w.recordBuf = append(w.recordBuf, src[loadIdx:scanIdx]...)

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.recordBuf = append(w.recordBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)
			continue
		}

		w.recordBuf = append(w.recordBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)
	}
}

// loadQF_memclearOn is called after a quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and handle escaped replacing of the first
// instance of quote or escape if applicable.
//
// It continues with appending the data up to a potentially additional quote or escape character, then
// appends the escaped version of that character and continues repeating that process for the rest of
// the field.
//
// Essentially the function does the same as the parent context except has no intent around overall
// quoting the field or detecting runes outside of the quote + escape character.
func (w *Writer) loadQF_memclearOn(src []byte, scanIdx int) {
	// escape any quote or escape runes found

	i := bytes.IndexAny(src[scanIdx:], w.escapeControlRunes)
	if i == -1 {
		w.appendRec(src)
		return
	}
	scanIdx += i

	w.appendRec(src[:scanIdx])

	for {
		r, n := utf8.DecodeRune(src[scanIdx:])
		scanIdx += n

		if w.quote == r {
			w.appendRec(w.escapedQuote[:w.escapedQuoteByteLen])
		} else {
			w.appendRec(w.escapedEscape[:w.escapedEscapeByteLen])
		}

		i = bytes.IndexAny(src[scanIdx:], w.escapeControlRunes)
		if i == -1 {
			w.appendRec(src[scanIdx:])
			return
		}

		scanIdx += i
	}
}

// loadQFWithCheckUTF8_memclearOn performs the same duties as loadQField_memclearOn and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (w *Writer) loadQFWithCheckUTF8_memclearOn(src []byte, scanIdx int) error {
	var loadIdx int
	for {
		r, n := utf8.DecodeRune(src[scanIdx:])
		if n == 0 {
			// all good and no overlap issues, so just directly copy src
			w.appendRec(src[loadIdx:])
			return nil
		}
		if n == 1 && r == utf8.RuneError {
			return ErrNonUTF8InRecord
		}

		if !strings.ContainsRune(w.escapeControlRunes, r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind
		//

		w.appendRec(src[loadIdx:scanIdx])

		scanIdx += n
		loadIdx = scanIdx

		if w.quote == r {
			w.appendRec(w.escapedQuote[:w.escapedQuoteByteLen])
			continue
		}

		w.appendRec(w.escapedEscape[:w.escapedEscapeByteLen])
	}
}
