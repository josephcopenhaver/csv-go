// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.

package csv

import (
	"bytes"
	"errors"
	"io"
	"strconv"
	"strings"
	"time"
	"unicode/utf8"
	"unsafe"
)

func (r *fastReader) prepareRow() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			// If performance testing points you to this copy operation as unreasonably hot, then see
			// "NOTE_ON_CHARACTER_SPLIT_HANDLING" and consider opening an issue / discussion for your case.

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c < utf8.RuneSelf {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0) a.k.a. `x >= startMBMin`
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							// NOTE_ON_CHARACTER_SPLIT_HANDLING:
							//
							// While this loop operation could aim for precision and optimize for having
							// the buffer as full as possible - it's realistically only up to 3 bytes
							// that will get hidden and immediately processed the next iteration or when
							// EOF is signaled. For the algorithm's purposes false positives are not
							// going to have a noticeable impact so using the simplest logic possible
							// is going to translate to speed. The buffer size is most likely going to
							// be vastly larger than 7 bytes as well so up to 3 bytes moving around is
							// going to be nothing in the grand scheme unless the buffer is far too large
							// and the copy operation crosses CPU cache zones.
							//
							// False negatives on the other hand would be devastating to the state
							// machine and must not be possible.
							//
							// Perhaps in the future we'll terminate the look-back early when an ascii
							// range value is found or the rune appears to be within an invalid code
							// range for utf8 encodings. If performance testing points you to here I
							// would love to know more about your case! We must always be willing to
							// reserve some bytes should a utf8 character byte sequence have been
							// split when reading a chunk, so if you land here it might be that your
							// data is best expressed in another format.

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if r.rawBuf[len(r.rawBuf)-i] >= startMBMin {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			c, size, di := r.controlRuneSet.indexAnyRuneLenInBytes(r.rawBuf[r.rawIndex:])
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:]...)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSepStartRune:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+1]...)

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.recordIndex++

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.recordIndex++

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSepStartRune = asciiCarriageReturn
					} else {
						r.recordSepRuneLen = 1
						r.recordSepStartRune = c
					}

					// preserve field separator
					var controlRuneSet runeSet6
					controlRuneSet.addRuneUniqueUnchecked(r.fieldSeparator)
					controlRuneSet.addRuneUniqueUnchecked(c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						controlRuneSet.addByte(asciiCarriageReturn)
						controlRuneSet.addByte(asciiLineFeed)
					}

					r.controlRuneSet = controlRuneSet

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					r.recordBuf = append(r.recordBuf, r.rawBuf[r.rawIndex:idx+int(size)]...)
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (r *secOpReader) prepareRow_memclearOn() bool {

	// TODO: reducing the instruction-space on the hot-positive path even after using code generation to filter
	// blocks out and dynamic controlRunes per state will have a compounding positive effect
	//
	// next step is to thoroughly get coverage though over this new approach in the discrete form before
	// it gets less verbose / more small via various tactics

	// Given r.rawIndex holds the next write index position,
	// if the raw buffer space is reaching its end (less than ReaderMinBufferSize bytes) then shift the unused segment
	// to the head of the buffer space and fill the tail of the buffer space until the available buffer length
	// is greater than or equal to ReaderMinBufferSize.
	//
	// After a sufficient segment is ready to parse, step through the state machine valid for the next found
	// control rune present in the stream buffer.

	for {
		if len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex < ReaderMinBufferSize {
			var lastProcessedByte byte
			if r.rawIndex > 0 {
				lastProcessedByte = r.rawBuf[r.rawIndex-1]
			}

			// If performance testing points you to this copy operation as unreasonably hot, then see
			// "NOTE_ON_CHARACTER_SPLIT_HANDLING" and consider opening an issue / discussion for your case.

			copy(r.rawBuf[0:cap(r.rawBuf)], r.rawBuf[r.rawIndex:len(r.rawBuf)+int(r.rawNumHiddenBytes)])
			r.rawBuf = r.rawBuf[:len(r.rawBuf)+int(r.rawNumHiddenBytes)-r.rawIndex]
			r.rawIndex = 0
			r.rawNumHiddenBytes = 0

			if (r.bitFlags & stEOF) == 0 {
				for {
					n, err := r.reader.Read(r.rawBuf[len(r.rawBuf):cap(r.rawBuf)])
					n += len(r.rawBuf)
					r.rawBuf = r.rawBuf[0:n]
					if err != nil {
						r.bitFlags |= stEOF
						if errors.Is(err, io.EOF) {
							if n == 0 {
								r.setDone()
								return r.handleEOF()
							}
						} else if n == 0 {
							r.setDone()
							r.ioErr(err)
							return false
						} else {
							r.readErr = err
						}
					}

					if n >= ReaderMinBufferSize {
						if c := r.rawBuf[n-1]; c < utf8.RuneSelf {
							// ends in 1 byte ascii character

							if c == asciiCarriageReturn && r.recordSepRuneLen != 1 {
								// hide a floating CR character if record separator
								// could be CRLF
								//
								// TODO: perhaps only do this if not in a
								// quoted state to reduce copying ops?
								//
								r.rawBuf = r.rawBuf[:len(r.rawBuf)-1]
								r.rawNumHiddenBytes = 1
							}

							break
						}

						if !endsInValidUTF8(r.rawBuf) {
							// does not end in a valid utf8 rune byte sequence and it may have
							// a byte or more truncated from the end
							//
							// so search the last three bytes backwards for one that begins with
							// 11xxxxxx (0xC0) a.k.a. `x >= startMBMin`
							//
							// if found, it could be the start of a utf8 rune that is truncated
							// so hide it and the other bytes after it if they exist
							//
							// This ensures that control runes which must be valid utf8 sequences
							// are reliably found and handled even if there are utf8 encoding errors
							// present in blocks of data bytes that have been "csv" encoded at the
							// "byte level" rather than the "rune level"

							// NOTE_ON_CHARACTER_SPLIT_HANDLING:
							//
							// While this loop operation could aim for precision and optimize for having
							// the buffer as full as possible - it's realistically only up to 3 bytes
							// that will get hidden and immediately processed the next iteration or when
							// EOF is signaled. For the algorithm's purposes false positives are not
							// going to have a noticeable impact so using the simplest logic possible
							// is going to translate to speed. The buffer size is most likely going to
							// be vastly larger than 7 bytes as well so up to 3 bytes moving around is
							// going to be nothing in the grand scheme unless the buffer is far too large
							// and the copy operation crosses CPU cache zones.
							//
							// False negatives on the other hand would be devastating to the state
							// machine and must not be possible.
							//
							// Perhaps in the future we'll terminate the look-back early when an ascii
							// range value is found or the rune appears to be within an invalid code
							// range for utf8 encodings. If performance testing points you to here I
							// would love to know more about your case! We must always be willing to
							// reserve some bytes should a utf8 character byte sequence have been
							// split when reading a chunk, so if you land here it might be that your
							// data is best expressed in another format.

							for i := 1; i <= rMaxOverflowNumBytes; i++ {
								if r.rawBuf[len(r.rawBuf)-i] >= startMBMin {
									r.rawNumHiddenBytes = uint8(i)
									r.rawBuf = r.rawBuf[:len(r.rawBuf)-i]
									break
								}
							}

							// break // is next instruction anyways, so commented out
						}

						break
					}

					if err != nil {
						break
					}
				}
			} else if len(r.rawBuf) == 0 {

				r.setDone()

				if r.readErr != nil {
					r.ioErr(r.readErr)
					return false
				}

				// if CRLF is the record sep, no error has been thrown before now
				// and we've reached EOF with the last byte being a CR
				//
				// It's unsafe to assume that the field has ended correctly and that
				// the file has been generated reliably.
				//
				// In such cases where strict RFC compliance is enabled and CRLF is supported
				// this character along with LF should be encased in quotes and an error should
				// be raised.
				//
				// An argument could be made that this should be allowed when rFlagErrOnNLInUF
				// is off that this should also be off, but I will not be making that decision
				// without a stronger opinion. A pull request with strong justification or a new
				// option would be welcome here should you have a strong opinion.
				if lastProcessedByte == asciiCarriageReturn && r.recordSepRuneLen == 2 {
					r.parsingErr(ErrUnsafeCRFileEnd)
					return false
				}

				return r.handleEOF()
			}
		}

	CHUNK_PROCESSOR:
		for {
			c, size, di := r.controlRuneSet.indexAnyRuneLenInBytes(r.rawBuf[r.rawIndex:])
			if di == -1 {
				// consume it all without adjustment

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							if len(r.rawBuf) == r.rawIndex+bomSize {
								r.byteIndex += uint64(bomSize)
								r.rawIndex = len(r.rawBuf)

								r.state = rStateStartOfRecord
								break CHUNK_PROCESSOR
							}
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					if r.appendRecBuf(r.rawBuf[r.rawIndex:]) {
						return false
					}

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: DATA_BLOCK_WITHOUT_CONTROL_RUNES

					// could zero out bytes immediately

					delta := len(r.rawBuf) - r.rawIndex
					if r.outOfCommentBytes(delta) {
						return false
					}

					// r.state = ... (unchanged)

					r.byteIndex += uint64(delta)
					r.rawIndex = len(r.rawBuf)
					break CHUNK_PROCESSOR
				}

				r.byteIndex += uint64(len(r.rawBuf) - r.rawIndex)
				r.rawIndex = len(r.rawBuf)
				break
			}
			idx := r.rawIndex + di

			// TODO: benchmark if skipping intermediate copies for signals not valid for a state saves time
			//
			// if it does then use multiple sets of runes for IndexAny operation

			switch c {
			case r.fieldSeparator:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.fieldSeparator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)

					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInQuotedField:
					// HANDLING: r.fieldSeparator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.fieldSeparator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.fieldSeparator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateStartOfField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					// r.state = ... (unchanged)
				case rStateInField:
					// HANDLING: r.fieldSeparator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)

					if r.fieldNumOverflow() {
						return false
					}
					r.byteIndex += uint64(size)

					r.fieldIndex++
					r.state = rStateStartOfField
				case rStateInLineComment:
					// HANDLING: r.fieldSeparator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.escape:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.escape

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
					fallthrough
				case rStateStartOfRecord, rStateStartOfField:
					// HANDLING: r.escape

					// an escape at the start of a record or field indicates that it is a literal
					// and not an escape character after all - it would be an escape indicator
					// if the state was one that indicated we're in a quoted field
					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField:
					// HANDLING: r.escape

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInQuotedFieldAfterEscape
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.escape

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.escape

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInField:
					// HANDLING: r.escape

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.escape

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.quote:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.quote

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)

							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here

							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInQuotedField:
					// HANDLING: r.quote

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateEndOfQuotedField
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateEndOfQuotedField:
					// HANDLING: r.quote

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					if (r.bitFlags & rFlagEscape) != 0 {
						r.streamParsingErr(ErrUnexpectedQuoteAfterField)
						return false
					}

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateStartOfField:
					// HANDLING: r.quote

					if di != 0 {
						if (r.bitFlags & rFlagErrOnQInUF) != 0 {
							// quote in unquoted field should cause an error

							r.byteIndex += uint64(di)
							r.streamParsingErr(ErrQuoteInUnquotedField)
							return false
						}

						// quote in unquoted field erroring is disabled

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInField
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)

					r.state = rStateInQuotedField
				case rStateInField:
					// HANDLING: r.quote

					if (r.bitFlags & rFlagErrOnQInUF) != 0 {
						// quote in unquoted field should cause an error

						r.byteIndex += uint64(di)
						r.streamParsingErr(ErrQuoteInUnquotedField)
						return false
					}

					// quote in unquoted field erroring is disabled

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInLineComment:
					// HANDLING: r.quote

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			case r.recordSepStartRune:
				if r.recordSepRuneLen == 2 {
					// checking for a full CRLF
					//
					// if not a CRLF sequence then just process the CR as field data

					if idx+int(size) >= len(r.rawBuf) || r.rawBuf[idx+int(size)] != asciiLineFeed {
						// definitely not a CRLF sequence, just an isolated CR byte
						// not followed by LF
						//
						// so treat as a field data byte

						switch r.state {
						case rStateStartOfDoc:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
								if (r.bitFlags & rFlagDropBOM) != 0 {
									r.byteIndex += uint64(bomSize)
									r.rawIndex += bomSize
									di -= bomSize
								}
							} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
								r.parsingErr(ErrNoByteOrderMarker)
								return false
							}

							// r.state = rStateStartOfRecord // removable bc next case clearly sets state to another value in all cases except for already fully covered record append failures while in StartOfRecord and the precursor states of it.
							fallthrough
						case rStateStartOfRecord, rStateStartOfField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							r.state = rStateInField
						case rStateInQuotedField, rStateInField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+1]) {
								return false
							}

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							// r.state = ... (unchanged)
						case rStateInQuotedFieldAfterEscape:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
							return false
						case rStateEndOfQuotedField:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF

							r.streamParsingErr(ErrInvalidQuotedFieldEnding)
							return false
						case rStateInLineComment:
							// HANDLING: (CR+EOF or CR+(!LF)) as data given recordSep=CRLF
							//
							// except in this comment context it's technically a line character
							// that starts a new conceptual line which could be rendered
							// in some virtualized or normalized fashion later

							// could zero out bytes immediately

							r.byteIndex += uint64(di) + uint64(size)
							r.rawIndex = idx + int(size)

							if r.outOfCommentLines() {
								return false
							}

							// r.state = ... (unchanged)
						}

						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// we are handling a CRLF sequence
					// so increase size by the length of LF
					// and continue with record separator processing
					size++
				}

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: record separator

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					// r.state = ... (unchanged)
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// commented out because it will always be zero here since state is rStateStartOfRecord
						// // reset field index since we're returning true after processing a record terminator/separator
						// //
						// // this tells the error tracer that we're done with the end field loading and should point to the next
						// // record's first field
						// r.fieldIndex = 0

						return true
					}
					return false
				case rStateInQuotedField:
					// HANDLING: record separator

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: record separator

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: record separator

					if di != 0 {
						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					}

					r.byteIndex += uint64(size)
					r.rawIndex += int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateStartOfField, rStateInField:
					// HANDLING: record separator

					if r.appendRecBuf(r.rawBuf[r.rawIndex:idx]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)

					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.incRecordIndex()

						// reset field index since we're returning true after processing a record terminator/separator
						//
						// this tells the error tracer that we're done with the end field loading and should point to the next
						// record's first field
						r.fieldIndex = 0

						return true
					}
					return false
				case rStateInLineComment:
					// HANDLING: record separator

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					r.state = rStateStartOfRecord
				}
			case r.comment:
				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: r.comment

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize
							di -= bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord:
					// HANDLING: r.comment

					if di == 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
						// definitely a line comment
						//
						// so mark bytes as handled and continue onwards

						if r.outOfCommentLines() {
							return false
						}

						r.byteIndex += uint64(size)
						r.rawIndex = idx + int(size)

						r.state = rStateInLineComment
						if r.rawIndex >= len(r.rawBuf) {
							break CHUNK_PROCESSOR
						}
						continue
					}

					// not a line comment, rather data that happens to contain
					// a comment rune
					fallthrough
				case rStateStartOfField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					r.state = rStateInField
				case rStateInQuotedField, rStateInField:
					// HANDLING: r.comment

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				case rStateEndOfQuotedField:
					// HANDLING: r.comment

					r.streamParsingErr(ErrInvalidQuotedFieldEnding)
					return false
				case rStateInLineComment:
					// HANDLING: r.comment

					// could zero out bytes immediately
					delta := di + int(size)
					if r.outOfCommentBytes(delta) {
						return false
					}

					r.byteIndex += uint64(delta)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				}
			default:
				if r.recordSepRuneLen != 0 {
					// record separator detection is disabled or already hardened
					//
					// must have found a CR or LF character under circumstances where we're aiming to error
					// if discovered outside of a quoted state
					switch r.state {
					case rStateStartOfDoc:
						// HANDLING: CR or LF as data given it does not match record-sep

						if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
							if (r.bitFlags & rFlagDropBOM) != 0 {
								r.byteIndex += uint64(bomSize)
								r.rawIndex += bomSize
								di -= bomSize

								// idx = r.rawIndex + di // will be net unchanged
							}
						} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
							r.parsingErr(ErrNoByteOrderMarker)
							return false
						}

						r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
						fallthrough
					case rStateStartOfRecord, rStateStartOfField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if di > 0 {
							r.state = rStateInField // might be removable, but leaving because could leave this context with the state set here
							r.byteIndex += uint64(di)
						}

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.byteIndex += uint64(di)

						if c == asciiLineFeed {
							r.streamParsingErr(errNewlineInUnquotedFieldLineFeed)
							return false
						}

						r.streamParsingErr(errNewlineInUnquotedFieldCarriageReturn)
						return false
					case rStateInQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
							return false
						}
						r.byteIndex += uint64(di) + uint64(size)
						r.rawIndex = idx + int(size)

						// r.state = ... (unchanged)
					case rStateInQuotedFieldAfterEscape:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
						return false
					case rStateEndOfQuotedField:
						// HANDLING: CR or LF as data given it does not match record-sep

						r.streamParsingErr(ErrInvalidQuotedFieldEnding)
						return false
					case rStateInLineComment:
						// HANDLING: CR or LF as data given it does not match record-sep

						// could zero out bytes immediately
						delta := di + int(size)
						if r.outOfCommentBytes(delta) {
							return false
						}

						r.byteIndex += uint64(delta)
						r.rawIndex = idx + int(size)
					}

					if r.rawIndex >= len(r.rawBuf) {
						break CHUNK_PROCESSOR
					}

					continue
				}

				//
				// record separator discovery handling block
				//
				// c contains the first rune of the record separator sequence
				//
				// only CRLF is a valid two-rune sequence, all others are one rune
				//

				switch r.state {
				case rStateStartOfDoc:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if bc, bomSize := utf8.DecodeRune(r.rawBuf[r.rawIndex:]); bc != utf8.RuneError && isByteOrderMarker(uint32(bc), bomSize) {
						if (r.bitFlags & rFlagDropBOM) != 0 {
							r.byteIndex += uint64(bomSize)
							r.rawIndex += bomSize

							// idx = r.rawIndex + di // will be net unchanged
						}
					} else if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
						r.parsingErr(ErrNoByteOrderMarker)
						return false
					}

					r.state = rStateStartOfRecord // might be removable, but leaving because could leave this context with the state set here
					fallthrough
				case rStateStartOfRecord, rStateEndOfQuotedField, rStateInLineComment, rStateStartOfField, rStateInField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					if c == asciiCarriageReturn && idx+1 < len(r.rawBuf) && r.rawBuf[idx+1] == asciiLineFeed {
						r.recordSepRuneLen = 2
						r.recordSepStartRune = asciiCarriageReturn
					} else {
						r.recordSepRuneLen = 1
						r.recordSepStartRune = c
					}

					// preserve field separator
					var controlRuneSet runeSet6
					controlRuneSet.addRuneUniqueUnchecked(r.fieldSeparator)
					controlRuneSet.addRuneUniqueUnchecked(c)

					if (r.bitFlags & rFlagQuote) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.quote)
					}
					if (r.bitFlags & rFlagEscape) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.escape)
					}
					if (r.bitFlags & rFlagComment) != 0 {
						controlRuneSet.addRuneUniqueUnchecked(r.comment)
					}

					if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
						// error on newline in unquoted field block

						controlRuneSet.addByte(asciiCarriageReturn)
						controlRuneSet.addByte(asciiLineFeed)
					}

					r.controlRuneSet = controlRuneSet

					// r.state = ... (unchanged)
				case rStateInQuotedField:
					// HANDLING: CR or LF as data given record-sep discovery=on

					// TODO: technically "skippable"

					if r.appendRecBuf(r.rawBuf[r.rawIndex : idx+int(size)]) {
						return false
					}
					r.byteIndex += uint64(di) + uint64(size)
					r.rawIndex = idx + int(size)

					// r.state = ... (unchanged)
				case rStateInQuotedFieldAfterEscape:
					// HANDLING: CR or LF as data given record-sep discovery=on

					r.streamParsingErr(ErrInvalidEscSeqInQuotedField)
					return false
				}
			}

			if r.rawIndex >= len(r.rawBuf) {
				break
			}
		}
	}
}

func (w *Writer) writeRow_memclearOff(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
					w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
					w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.recordBuf = src
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneSet.indexAnyInBytes(src)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, src...)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadQF_memclearOff(src, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(src) {
					w.recordBuf = append(w.recordBuf, src...)
					goto FIRST_FIELD_WRITTEN
				}

				b := src[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneSet.containsSingleByteRune(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneSet.containsMBRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

		err = w.loadQFWithCheckUTF8_memclearOff(src, i)
		if err != nil {
			return 0, err
		}

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.recordBuf = w.fieldSepSeq.appendText(w.recordBuf)

		f := &fields[i]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.recordBuf = src
				continue
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneSet.indexAnyInBytes(src)
			if i == -1 {
				w.recordBuf = append(w.recordBuf, src...)
				continue
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadQF_memclearOff(src, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(src) {
				w.recordBuf = append(w.recordBuf, src...)
				break
			}
			if b := src[i]; b < utf8.RuneSelf {
				if !w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind
			//

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			err = w.loadQFWithCheckUTF8_memclearOff(src, i)
			if err != nil {
				return 0, err
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			break
		}
	}

	w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

func (w *Writer) writeStrRow_memclearOff(fields []string) (int, error) {
	// write the first field
	{
		s := fields[0]
		if len(s) == 0 {
			if len(fields) == 1 {
				w.recordBuf = w.twoQuotesSeq.appendText(w.recordBuf)
				w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

				n, err := w.writer.Write(w.recordBuf)
				if err != nil {
					err = writeIOErr{err}
				}
				return n, err
			}
			goto FIRST_FIELD_WRITTEN
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneSet.indexAnyInString(s)
				if i == -1 {
					w.recordBuf = append(w.recordBuf, s...)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadStrQF_memclearOff(s, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(s) {
					w.recordBuf = append(w.recordBuf, s...)
					goto FIRST_FIELD_WRITTEN
				}

				b := s[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneSet.containsSingleByteRune(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneSet.containsMBRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

		if err := w.loadStrQFWithCheckUTF8_memclearOff(s, i); err != nil {
			return 0, err
		}

		w.recordBuf = w.quoteSeq.appendText(w.recordBuf)
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.recordBuf = w.fieldSepSeq.appendText(w.recordBuf)

		s := fields[i]
		if len(s) == 0 {
			continue
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneSet.indexAnyInString(s)
			if i == -1 {
				w.recordBuf = append(w.recordBuf, s...)
				continue
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			w.loadStrQF_memclearOff(s, i)

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(s) {
				w.recordBuf = append(w.recordBuf, s...)
				break
			}

			if b := s[i]; b < utf8.RuneSelf {
				if !w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			if err := w.loadStrQFWithCheckUTF8_memclearOff(s, i); err != nil {
				return 0, err
			}

			w.recordBuf = w.quoteSeq.appendText(w.recordBuf)

			break
		}
	}

	w.recordBuf = w.recordSepSeq.appendText(w.recordBuf)

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

func (w *Writer) writeRow_memclearOn(fields []FieldWriter) (int, error) {
	// write the first field
	{
		f := &fields[0]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				if len(fields) == 1 {
					w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
					w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				if len(fields) == 1 {
					w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
					w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

					n, err := w.writer.Write(w.recordBuf)
					if err != nil {
						err = writeIOErr{err}
					}
					return n, err
				}
				goto FIRST_FIELD_WRITTEN
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.setRecordBuf(src)
				goto FIRST_FIELD_WRITTEN
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneSet.indexAnyInBytes(src)
				if i == -1 {
					w.appendRec(src)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadQF_memclearOn(src, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(src) {
					w.appendRec(src)
					goto FIRST_FIELD_WRITTEN
				}

				b := src[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneSet.containsSingleByteRune(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneSet.containsMBRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

		err = w.loadQFWithCheckUTF8_memclearOn(src, i)
		if err != nil {
			return 0, err
		}

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.setRecordBuf(w.fieldSepSeq.appendText(w.recordBuf))

		f := &fields[i]

		var scanForNonUTF8 bool
		var src []byte
		var err error

		switch f.kind {
		case wfkBytes:
			src = f.bytes
			if len(src) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
		case wfkString:
			s := f.str
			if len(s) == 0 {
				continue
			}

			scanForNonUTF8 = (f._64_bits == 0)
			src = unsafe.Slice(unsafe.StringData(s), len(s))
		case wfkRune:
			src, err = f.runeAppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}

			// src is now guaranteed to be a utf8 encoded non-empty byte sequence
			// so scanForNonUTF8 will remain false here intentionally
		default:
			if (w.bitFlags & wFlagControlRuneOverlap) == 0 {
				src, err = f.AppendText(w.recordBuf)
				if err != nil {
					return 0, err
				}

				w.setRecordBuf(src)
				continue
			}

			src, err = f.AppendText(w.fieldWriterBuf[:0])
			if err != nil {
				return 0, err
			}
		}

		//
		// process src buf
		//

		if !scanForNonUTF8 || (w.bitFlags&wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneSet.indexAnyInBytes(src)
			if i == -1 {
				w.appendRec(src)
				continue
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadQF_memclearOn(src, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(src) {
				w.appendRec(src)
				break
			}
			if b := src[i]; b < utf8.RuneSelf {
				if !w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(src[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind
			//

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			err = w.loadQFWithCheckUTF8_memclearOn(src, i)
			if err != nil {
				return 0, err
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			break
		}
	}

	w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

func (w *Writer) writeStrRow_memclearOn(fields []string) (int, error) {
	// write the first field
	{
		s := fields[0]
		if len(s) == 0 {
			if len(fields) == 1 {
				w.setRecordBuf(w.twoQuotesSeq.appendText(w.recordBuf))
				w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

				n, err := w.writer.Write(w.recordBuf)
				if err != nil {
					err = writeIOErr{err}
				}
				return n, err
			}
			goto FIRST_FIELD_WRITTEN
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			var i int
			if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
				i = w.controlRuneSet.indexAnyInString(s)
				if i == -1 {
					w.appendStrRec(s)
					goto FIRST_FIELD_WRITTEN
				}
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadStrQF_memclearOn(s, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			goto FIRST_FIELD_WRITTEN
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		if (w.bitFlags & wFlagForceQuoteFirstField) == 0 {
			for {
				if i >= len(s) {
					w.appendStrRec(s)
					goto FIRST_FIELD_WRITTEN
				}

				b := s[i]
				if b < utf8.RuneSelf {
					if !w.controlRuneSet.containsSingleByteRune(b) {
						i++
						continue
					}
				} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
					return 0, ErrNonUTF8InRecord
				} else if !w.controlRuneSet.containsMBRune(r) {
					i += n
					continue
				}

				break
			}
		}

		//
		// found a control rune of some kind or was forced to quote first field
		//

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

		if err := w.loadStrQFWithCheckUTF8_memclearOn(s, i); err != nil {
			return 0, err
		}

		w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))
	}

FIRST_FIELD_WRITTEN:

	for i := 1; i < len(fields); i++ {
		w.setRecordBuf(w.fieldSepSeq.appendText(w.recordBuf))

		s := fields[i]
		if len(s) == 0 {
			continue
		}

		//
		// process src buf
		//

		if (w.bitFlags & wFlagErrOnNonUTF8) == 0 {
			// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

			i := w.controlRuneSet.indexAnyInString(s)
			if i == -1 {
				w.appendStrRec(s)
				continue
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			w.loadStrQF_memclearOn(s, i)

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			continue
		}

		// for each decoded rune, check if that rune fails to decode and if so then return an error
		// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
		// continue loading

		var i int
		for {
			if i >= len(s) {
				w.appendStrRec(s)
				break
			}

			if b := s[i]; b < utf8.RuneSelf {
				if !w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				return 0, ErrNonUTF8InRecord
			} else if !w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			//
			// found a control rune of some kind or was forced to quote first field
			//

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			if err := w.loadStrQFWithCheckUTF8_memclearOn(s, i); err != nil {
				return 0, err
			}

			w.setRecordBuf(w.quoteSeq.appendText(w.recordBuf))

			break
		}
	}

	w.setRecordBuf(w.recordSepSeq.appendText(w.recordBuf))

	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err = writeIOErr{err}
	}
	return n, err
}

//
// runeSetBase contains common behavior utilized by runeSet4 and runeSet6
//

type runeSetBase struct {
	mbRuneCount uint8
	singleBytes [4]uint64
	mbByteEnds  uint64
}

// addByte assumes that the byte is a valid Unicode value less than 128
//
// any change to this function likely needs to be replicated to addRuneUniqueUnchecked()
func (rs *runeSetBase) addByte(b byte) {
	rs.singleBytes[b>>6] |= (uint64(1) << (b & 63))
}

// containsSingleByteRune would normally only work correctly when the input byte is less than utf8.RuneSelf
// however the bit set is wide enough to support all 256 bits - consuming 16 bytes more of memory to avoid
// an if-check and a bit-mask (to ensure bounds check elimination kicks in) which has shown to be definitely
// faster.
func (rs *runeSetBase) containsSingleByteRune(b byte) bool {
	return (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0
}

// internalContainsMBEndByte works with either the last byte of a utf8 encoded multi-byte rune
// or the 8 least significant bits of a rune since it only cares about the lower 6 bits
// and the first two bits are guaranteed to be `10` or noise by the nature of the calling context.
func (rs *runeSetBase) internalContainsMBEndByte(b byte) bool {
	return (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0
}

//
// NOTE: non-generated contents relevant to runeSet4 are present in fast_csv_rune_set.go
//

// runeSet4 is useful for csv writing as the Writer will only have up to 4 multi-byte runes ever in config.
//
// The 4 suffix indicates that at most 4 multi-byte runes are supported by the algorithms within this struct
// which is done for efficiency reasons.
//
// invariants:
// - utilizing context maintains that there will never be more than 4 multi-byte runes placed in the set
type runeSet4 struct {
	runeSetBase
	mbRunes [4]rune
}

// addRune assumes that the rune is a valid Unicode value
func (rs *runeSet4) addRune(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.addMBRune(r)
}

// internalContainsMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
func (rs *runeSet4) internalContainsMBRune(r rune) bool {

	// unwound the loop search to avoid loop overhead
	//
	// becomes a fast series of opcodes when compiled
	//
	// it is end-state equivalent to the following:
	//
	//
	// for i := range rs.mbRuneCount {
	// 	if rs.mbRunes[i] == r {
	// 		return true
	// 	}
	// }
	//
	// return false

	switch rs.mbRuneCount {
	case 4:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r)
	case 3:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r)
	case 2:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r)
	case 1:
		return (rs.mbRunes[0] == r)
	}

	return false
}

func (rs *runeSet4) containsMBRune(r rune) bool {
	fastEndCheckOK := ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (r & 63))) != 0)
	return fastEndCheckOK && rs.internalContainsMBRune(r)
}

// addMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
//
// any change to this function likely needs to be replicated to addRuneUniqueUnchecked()
func (rs *runeSet4) addMBRune(r rune) {
	if rs.internalContainsMBRune(r) {
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds |= (uint64(1) << (r & 63))
}

// internalContainsRune assumes that the rune is a valid Unicode value
func (rs *runeSet4) internalContainsRune(r rune) bool {
	if r < utf8.RuneSelf {
		return ( /* inlined call to containsSingleByteRune: */ (rs.singleBytes[byte(r)>>6] & (uint64(1) << (r & 63))) != 0)
	}

	return rs.internalContainsMBRune(r)
}

// addRuneUniqueUnchecked assumes that the rune is a valid Unicode value that (if it is multi-byte when encoded) has not already been added before
//
// any change to this function likely needs to be replicated to addMBRune() or addByte()
func (rs *runeSet4) addRuneUniqueUnchecked(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds |= (uint64(1) << (r & 63))
}

func (rs *runeSet4) indexAnyInBytes(p []byte) int {
	if rs.mbRuneCount == 0 {

		for i, b := range p {
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}
		}

		return -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i, b := range p {

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := p[i-3], p[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(p[i-1]&0x3F)<<6 | rune(b&0x3F))
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := p[i-2], p[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
				case 1:

					// assemble the full 2-byte rune value

					r = rune(p[i-1]&0x1F)<<6 | rune(b&0x3F)
				}

				if rs.internalContainsMBRune(r) {
					return lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return -1
}

func (rs *runeSet4) indexAnyInString(s string) int {
	if rs.mbRuneCount == 0 {
		for i := range len(s) {
			b := s[i]
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}
		}

		return -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i := range len(s) {
		b := s[i]

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := s[i-3], s[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(s[i-1]&0x3F)<<6 | rune(b&0x3F))
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := s[i-2], s[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
				case 1:

					// assemble the full 2-byte rune value

					r = rune(s[i-1]&0x1F)<<6 | rune(b&0x3F)
				}

				if rs.internalContainsMBRune(r) {
					return lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return -1
}

func (rs *runeSet4) indexAnyRuneLenInBytes(p []byte) (rune, uint8, int) {
	if rs.mbRuneCount == 0 {

		for i, b := range p {
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}
		}

		return 0, 0, -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i, b := range p {

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				var n uint8
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := p[i-3], p[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(p[i-1]&0x3F)<<6 | rune(b&0x3F))
					n = 4
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := p[i-2], p[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
					n = 3
				case 1:

					// assemble the full 2-byte rune value

					r = rune(p[i-1]&0x1F)<<6 | rune(b&0x3F)
					n = 2
				}

				if rs.internalContainsMBRune(r) {
					return r, n, lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return 0, 0, -1
}

func (rs *runeSet4) indexAnyRuneLenInString(s string) (rune, uint8, int) {
	if rs.mbRuneCount == 0 {
		for i := range len(s) {
			b := s[i]
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}
		}

		return 0, 0, -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i := range len(s) {
		b := s[i]

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				var n uint8
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := s[i-3], s[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(s[i-1]&0x3F)<<6 | rune(b&0x3F))
					n = 4
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := s[i-2], s[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
					n = 3
				case 1:

					// assemble the full 2-byte rune value

					r = rune(s[i-1]&0x1F)<<6 | rune(b&0x3F)
					n = 2
				}

				if rs.internalContainsMBRune(r) {
					return r, n, lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return 0, 0, -1
}

//
// NOTE: non-generated contents relevant to runeSet6 are present in fast_csv_rune_set.go
//

// runeSet6 is useful for csv reading as the Reader will only have up to 6 multi-byte runes ever in config.
//
// The 6 suffix indicates that at most 6 multi-byte runes are supported by the algorithms within this struct
// which is done for efficiency reasons.
//
// invariants:
// - utilizing context maintains that there will never be more than 6 multi-byte runes placed in the set
type runeSet6 struct {
	runeSetBase
	mbRunes [6]rune
}

// addRune assumes that the rune is a valid Unicode value
func (rs *runeSet6) addRune(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.addMBRune(r)
}

// internalContainsMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
func (rs *runeSet6) internalContainsMBRune(r rune) bool {

	// unwound the loop search to avoid loop overhead
	//
	// becomes a fast series of opcodes when compiled
	//
	// it is end-state equivalent to the following:
	//
	//
	// for i := range rs.mbRuneCount {
	// 	if rs.mbRunes[i] == r {
	// 		return true
	// 	}
	// }
	//
	// return false

	switch rs.mbRuneCount {
	case 6:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r || rs.mbRunes[4] == r || rs.mbRunes[5] == r)
	case 5:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r || rs.mbRunes[4] == r)
	case 4:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r || rs.mbRunes[3] == r)
	case 3:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r || rs.mbRunes[2] == r)
	case 2:
		return (rs.mbRunes[0] == r || rs.mbRunes[1] == r)
	case 1:
		return (rs.mbRunes[0] == r)
	}

	return false
}

func (rs *runeSet6) containsMBRune(r rune) bool {
	fastEndCheckOK := ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (r & 63))) != 0)
	return fastEndCheckOK && rs.internalContainsMBRune(r)
}

// addMBRune assumes that the rune is a valid Unicode value that encodes to more than one byte
//
// any change to this function likely needs to be replicated to addRuneUniqueUnchecked()
func (rs *runeSet6) addMBRune(r rune) {
	if rs.internalContainsMBRune(r) {
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds |= (uint64(1) << (r & 63))
}

// internalContainsRune assumes that the rune is a valid Unicode value
func (rs *runeSet6) internalContainsRune(r rune) bool {
	if r < utf8.RuneSelf {
		return ( /* inlined call to containsSingleByteRune: */ (rs.singleBytes[byte(r)>>6] & (uint64(1) << (r & 63))) != 0)
	}

	return rs.internalContainsMBRune(r)
}

// addRuneUniqueUnchecked assumes that the rune is a valid Unicode value that (if it is multi-byte when encoded) has not already been added before
//
// any change to this function likely needs to be replicated to addMBRune() or addByte()
func (rs *runeSet6) addRuneUniqueUnchecked(r rune) {
	if r < utf8.RuneSelf {
		rs.addByte(byte(r))
		return
	}

	rs.mbRunes[rs.mbRuneCount] = r
	rs.mbRuneCount++

	rs.mbByteEnds |= (uint64(1) << (r & 63))
}

func (rs *runeSet6) indexAnyInBytes(p []byte) int {
	if rs.mbRuneCount == 0 {

		for i, b := range p {
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}
		}

		return -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i, b := range p {

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := p[i-3], p[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(p[i-1]&0x3F)<<6 | rune(b&0x3F))
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := p[i-2], p[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
				case 1:

					// assemble the full 2-byte rune value

					r = rune(p[i-1]&0x1F)<<6 | rune(b&0x3F)
				}

				if rs.internalContainsMBRune(r) {
					return lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return -1
}

func (rs *runeSet6) indexAnyInString(s string) int {
	if rs.mbRuneCount == 0 {
		for i := range len(s) {
			b := s[i]
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}
		}

		return -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i := range len(s) {
		b := s[i]

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := s[i-3], s[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(s[i-1]&0x3F)<<6 | rune(b&0x3F))
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := s[i-2], s[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
				case 1:

					// assemble the full 2-byte rune value

					r = rune(s[i-1]&0x1F)<<6 | rune(b&0x3F)
				}

				if rs.internalContainsMBRune(r) {
					return lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return -1
}

func (rs *runeSet6) indexAnyRuneLenInBytes(p []byte) (rune, uint8, int) {
	if rs.mbRuneCount == 0 {

		for i, b := range p {
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}
		}

		return 0, 0, -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i, b := range p {

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				var n uint8
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := p[i-3], p[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(p[i-1]&0x3F)<<6 | rune(b&0x3F))
					n = 4
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := p[i-2], p[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
					n = 3
				case 1:

					// assemble the full 2-byte rune value

					r = rune(p[i-1]&0x1F)<<6 | rune(b&0x3F)
					n = 2
				}

				if rs.internalContainsMBRune(r) {
					return r, n, lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return 0, 0, -1
}

func (rs *runeSet6) indexAnyRuneLenInString(s string) (rune, uint8, int) {
	if rs.mbRuneCount == 0 {
		for i := range len(s) {
			b := s[i]
			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}
		}

		return 0, 0, -1
	}

	var mbRuneIdxDiff int
	lastMBStartIdx := invalidMBStartIdx
	for i := range len(s) {
		b := s[i]

		if b < utf8.RuneSelf {
			// matched ascii character

			if /* inlined call to containsSingleByteRune: */ (rs.singleBytes[b>>6] & (uint64(1) << (b & 63))) != 0 {
				return rune(b), 1, i
			}

			lastMBStartIdx = invalidMBStartIdx
			continue
		}

		if b < startMBMin {
			// matched continuation byte

			if (i-lastMBStartIdx) == mbRuneIdxDiff && ( /* inlined call to internalContainsMBEndByte: */ (rs.mbByteEnds & (uint64(1) << (b & 63))) != 0) {
				// invariant: mbRuneIdxDiff is within [1,3] when this block is entered

				// since mbRuneIdxDiff is the difference between included byte index positions for a rune to decode
				// case values will be 1 less than the number of bytes to load i.e.
				//
				// 3 -> index1 - index4; 2 -> index1 - index3; 1 -> index1 - index2
				//
				// also startByteIdx = i - mbRuneIdxDiff
				//
				// also given the way i, lastMBStartIdx, and mbRuneIdxDiff change over time mbRuneIdxDiff can only be within [1,3]
				// when this block is entered so no default on the switch is required.

				var r rune
				var n uint8
				switch mbRuneIdxDiff {
				case 3:
					// Invariants: b0 in [0xF0..0xF4]; b1,b2,b3 are 0b10xxxxxx.
					b0, b1 := s[i-3], s[i-2]
					switch b0 {
					case 0xF0:
						// block over-longs
						if b1 < 0x90 {
							continue
						}
					case 0xF4:
						// would be outside the unicode plane above U+10FFFF
						if b1 > 0x8F {
							continue
						}
					}

					// assemble the full 4-byte rune value

					r = (rune(b0&0x07)<<18 | rune(b1&0x3F)<<12 | rune(s[i-1]&0x3F)<<6 | rune(b&0x3F))
					n = 4
				case 2:
					// Invariants: b0 in [0xE0..0xEF]; b1,b2 are 0b10xxxxxx.
					b0, b1 := s[i-2], s[i-1]
					switch b0 {
					case 0xE0:
						// block over-longs
						if b1 < 0xA0 {
							continue
						}
					case 0xED:
						// block surrogates
						if b1 > 0x9F {
							continue
						}
					}

					// assemble the full 3-byte rune value

					r = (rune(b0&0x0F)<<12 | rune(b1&0x3F)<<6 | rune(b&0x3F))
					n = 3
				case 1:

					// assemble the full 2-byte rune value

					r = rune(s[i-1]&0x1F)<<6 | rune(b&0x3F)
					n = 2
				}

				if rs.internalContainsMBRune(r) {
					return r, n, lastMBStartIdx
				}
			}

			continue
		}

		// matched start of multi-byte rune

		switch leadingOnes8(b) {
		case 4:
			if b <= startMBMax {
				lastMBStartIdx = i
				mbRuneIdxDiff = 3
				continue
			}
		case 3:
			lastMBStartIdx = i
			mbRuneIdxDiff = 2
			continue
		case 2:
			if b >= startMB2ByteMin {
				lastMBStartIdx = i
				mbRuneIdxDiff = 1
				continue
			}
		}

		lastMBStartIdx = invalidMBStartIdx
	}

	return 0, 0, -1
}

const len8LeadingOnesTab = "" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01" +
	"\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02" +
	"\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02" +
	"\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03" +
	"\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x07\x08"

// leadingOnes8 returns the number of leading one bits in x; the result is 0 for x == 0 and 8 for 255.
func leadingOnes8(b byte) uint8 {
	return len8LeadingOnesTab[b]
}

func (rw *RecordWriter) preflightCheck_memclearOff() bool {
	if rw.err != nil {
		if rw.err == ErrRecordWritten {
			rw.err = ErrRecordWriterClosed
		}
		return false
	}

	switch rw.nextField {
	case 0:
		rw.bitFlags = rw.w.bitFlags
		if err := rw.w.err; err != nil {
			// if the parent writer has the closed bit set
			// then the err value we just read is guaranteed to be non-nil
			//
			// so we ensure it is unset in this context just before we abort
			// because that close flag reflects the writer state, not the rw
			// instance state which should be scrubbed in this case.
			//
			// if it was not unset then abort would short-circuit early
			rw.bitFlags &= (^wFlagClosed)
			rw.abort(err)
			return false
		}

		rw.numFields = rw.w.numFields
		rw.recordBuf = rw.recordBuf[:0]
		if rw.w.comment != invalidControlRune && (rw.bitFlags&wFlagFirstRecordWritten) == 0 {
			rw.bitFlags |= wFlagForceQuoteFirstField
		}
	case 1:
		rw.bitFlags &= (^wFlagForceQuoteFirstField)
		fallthrough
	default:
		rw.recordBuf = rw.w.fieldSepSeq.appendText(rw.recordBuf)
	}

	rw.nextField++

	return true
}

func (rw *RecordWriter) unsafeAppendUTF8FieldBytes_memclearOff(p []byte) {
	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		i = rw.w.controlRuneSet.indexAnyInBytes(p)
		if i == -1 {
			rw.recordBuf = append(rw.recordBuf, p...)
			return
		}
	}

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

	rw.loadQF_memclearOff(p, i)

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)
}

func (rw *RecordWriter) bytes_memclearOff(p []byte, disableUTF8Check bool) {
	if disableUTF8Check || (rw.bitFlags&wFlagErrOnNonUTF8) == 0 {
		// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

		var i int
		if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
			i = rw.w.controlRuneSet.indexAnyInBytes(p)
			if i == -1 {
				rw.recordBuf = append(rw.recordBuf, p...)
				return
			}
		}

		rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

		rw.loadQF_memclearOff(p, i)

		rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

		return
	}

	// for each decoded rune, check if that rune fails to decode and if so then return an error
	// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
	// continue loading

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		for {
			if i >= len(p) {
				rw.recordBuf = append(rw.recordBuf, p...)
				return
			}

			b := p[i]
			if b < utf8.RuneSelf {
				if !rw.w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(p[i:]); n == 1 {
				rw.abort(ErrNonUTF8InRecord)
				return
			} else if !rw.w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			break
		}
	}

	//
	// found a control rune of some kind or was forced to quote first field
	//

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

	err := rw.loadQFWithCheckUTF8_memclearOff(p, i)
	if err != nil {
		rw.abort(err)
		return
	}

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)
}

func (rw *RecordWriter) string_memclearOff(s string, disableUTF8Check bool) {
	if disableUTF8Check || (rw.bitFlags&wFlagErrOnNonUTF8) == 0 {
		// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

		var i int
		if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !strings.HasPrefix(s, string(rw.w.comment)) {
			i = rw.w.controlRuneSet.indexAnyInString(s)
			if i == -1 {
				rw.recordBuf = append(rw.recordBuf, s...)
				return
			}
		}

		rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

		rw.loadStrQF_memclearOff(s, i)

		rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

		return
	}

	// for each decoded rune, check if that rune fails to decode and if so then return an error
	// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
	// continue loading

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !strings.HasPrefix(s, string(rw.w.comment)) {
		for {
			if i >= len(s) {
				rw.recordBuf = append(rw.recordBuf, s...)
				return
			}

			b := s[i]
			if b < utf8.RuneSelf {
				if !rw.w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				rw.abort(ErrNonUTF8InRecord)
				return
			} else if !rw.w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			break
		}
	}

	//
	// found a control rune of some kind or was forced to quote first field
	//

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)

	err := rw.loadStrQFWithCheckUTF8_memclearOff(s, i)
	if err != nil {
		rw.abort(err)
		return
	}

	rw.recordBuf = rw.w.quoteSeq.appendText(rw.recordBuf)
}

func (rw *RecordWriter) int64_memclearOff(i int64) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.recordBuf = strconv.AppendInt(rw.recordBuf, i, 10)
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(strconv.AppendInt(rw.w.fieldWriterBuf[:0], i, 10))
}

func (rw *RecordWriter) uint64_memclearOff(i uint64) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.recordBuf = strconv.AppendUint(rw.recordBuf, i, 10)
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(strconv.AppendUint(rw.w.fieldWriterBuf[:0], i, 10))
}

func (rw *RecordWriter) time_memclearOff(t time.Time) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.recordBuf = t.AppendFormat(rw.recordBuf, time.RFC3339Nano)
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(t.AppendFormat(rw.w.fieldWriterBuf[:0], time.RFC3339Nano))
}

func (rw *RecordWriter) bool_memclearOff(b bool) {

	v := byte('0')
	if b {
		v += 1
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.recordBuf = append(rw.recordBuf, v)
		return
	}

	rw.w.fieldWriterBuf[0] = v
	rw.unsafeAppendUTF8FieldBytes_memclearOff(rw.w.fieldWriterBuf[:1])
}

func (rw *RecordWriter) float64_memclearOff(f float64) {

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.recordBuf = strconv.AppendFloat(rw.recordBuf, f, 'g', -1, 64)
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(strconv.AppendFloat(rw.w.fieldWriterBuf[:0], f, 'g', -1, 64))
}

func (rw *RecordWriter) rune_withCheckUTF8_memclearOff(r rune) {
	if !utf8.ValidRune(r) {
		rw.abort(ErrInvalidRune)
		return
	}

	if (rw.bitFlags & wFlagForceQuoteFirstField) == 0 {
		if r < utf8.RuneSelf {
			if !rw.w.controlRuneSet.containsSingleByteRune(byte(r)) {
				goto SIMPLE_APPEND
			}
		} else if !rw.w.controlRuneSet.containsMBRune(r) {
			goto SIMPLE_APPEND
		}
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(utf8.AppendRune(rw.w.fieldWriterBuf[:0], r))
	return

SIMPLE_APPEND:
	rw.recordBuf = utf8.AppendRune(rw.recordBuf, r)
}

func (rw *RecordWriter) rune_memclearOff(r rune) {
	if (rw.bitFlags & wFlagForceQuoteFirstField) == 0 {
		if r < utf8.RuneSelf {
			if !rw.w.controlRuneSet.containsSingleByteRune(byte(r)) {
				goto SIMPLE_APPEND
			}
		} else if !rw.w.controlRuneSet.containsMBRune(r) {
			goto SIMPLE_APPEND
		}
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOff(utf8.AppendRune(rw.w.fieldWriterBuf[:0], r))
	return

SIMPLE_APPEND:
	rw.recordBuf = utf8.AppendRune(rw.recordBuf, r)
}

func (rw *RecordWriter) write_memclearOff() (int, error) {
	wErr := rw.w.err

	if err := rw.err; err != nil {
		if wErr == nil {
			rw.w.bitFlags |= wFlagHeaderWritten
		}

		return 0, err
	}

	switch rw.nextField {
	case 0:
		if wErr == nil {
			rw.w.bitFlags |= wFlagHeaderWritten
		}

		err := ErrRowNilOrEmpty
		rw.abort(err)
		return 0, err
	case 1:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = 1
		} else if numFields != 1 {
			if wErr == nil {
				rw.w.bitFlags |= wFlagHeaderWritten
			}

			err := ErrInvalidFieldCountInRecord
			rw.abort(err)
			return 0, err
		}
		if len(rw.recordBuf) == 0 {
			rw.recordBuf = rw.w.twoQuotesSeq.appendText(rw.recordBuf)
		}
	default:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = rw.nextField
		} else if numFields != rw.nextField {
			if wErr == nil {
				rw.w.bitFlags |= wFlagHeaderWritten
			}

			err := ErrInvalidFieldCountInRecord
			rw.abort(err)
			return 0, err
		}
	}

	rw.recordBuf = rw.w.recordSepSeq.appendText(rw.recordBuf)
	rw.nextField = 0

	if wErr != nil {
		rw.abort(wErr)
		return 0, wErr
	}

	// re-checkin the buffer then flush it to the internal writer

	rw.bitFlags |= wFlagClosed
	recordBuf := rw.recordBuf
	rw.w.recordBuf = recordBuf
	rw.w.bitFlags = (rw.w.bitFlags & (^wFlagRecordBuffCheckedOut)) | (wFlagFirstRecordWritten | wFlagHeaderWritten)

	n, err := rw.w.writer.Write(recordBuf)
	if err != nil {
		err = writeIOErr{err}
		if rw.w.err == nil {
			rw.w.setErr(err)
		}

		// no need to re-unset the rw.bitFlags wFlagClosed bit since
		// the parent writer context now owns the record buffer again
		//
		// parent writer will clear it when closed

		rw.abort(err)
	} else {
		rw.err = ErrRecordWritten
	}
	return n, err
}

func (rw *RecordWriter) preflightCheck_memclearOn() bool {
	if rw.err != nil {
		if rw.err == ErrRecordWritten {
			rw.err = ErrRecordWriterClosed
		}
		return false
	}

	switch rw.nextField {
	case 0:
		rw.bitFlags = rw.w.bitFlags
		if err := rw.w.err; err != nil {
			// if the parent writer has the closed bit set
			// then the err value we just read is guaranteed to be non-nil
			//
			// so we ensure it is unset in this context just before we abort
			// because that close flag reflects the writer state, not the rw
			// instance state which should be scrubbed in this case.
			//
			// if it was not unset then abort would short-circuit early
			rw.bitFlags &= (^wFlagClosed)
			rw.abort(err)
			return false
		}

		rw.numFields = rw.w.numFields
		rw.recordBuf = rw.recordBuf[:0]
		if rw.w.comment != invalidControlRune && (rw.bitFlags&wFlagFirstRecordWritten) == 0 {
			rw.bitFlags |= wFlagForceQuoteFirstField
		}
	case 1:
		rw.bitFlags &= (^wFlagForceQuoteFirstField)
		fallthrough
	default:
		rw.setRecordBuf(rw.w.fieldSepSeq.appendText(rw.recordBuf))
	}

	rw.nextField++

	return true
}

func (rw *RecordWriter) unsafeAppendUTF8FieldBytes_memclearOn(p []byte) {
	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		i = rw.w.controlRuneSet.indexAnyInBytes(p)
		if i == -1 {
			rw.appendRec(p)
			return
		}
	}

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

	rw.loadQF_memclearOn(p, i)

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))
}

func (rw *RecordWriter) bytes_memclearOn(p []byte, disableUTF8Check bool) {
	if disableUTF8Check || (rw.bitFlags&wFlagErrOnNonUTF8) == 0 {
		// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

		var i int
		if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
			i = rw.w.controlRuneSet.indexAnyInBytes(p)
			if i == -1 {
				rw.appendRec(p)
				return
			}
		}

		rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

		rw.loadQF_memclearOn(p, i)

		rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

		return
	}

	// for each decoded rune, check if that rune fails to decode and if so then return an error
	// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
	// continue loading

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !bytes.HasPrefix(p, []byte(string(rw.w.comment))) {
		for {
			if i >= len(p) {
				rw.appendRec(p)
				return
			}

			b := p[i]
			if b < utf8.RuneSelf {
				if !rw.w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRune(p[i:]); n == 1 {
				rw.abort(ErrNonUTF8InRecord)
				return
			} else if !rw.w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			break
		}
	}

	//
	// found a control rune of some kind or was forced to quote first field
	//

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

	err := rw.loadQFWithCheckUTF8_memclearOn(p, i)
	if err != nil {
		rw.abort(err)
		return
	}

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))
}

func (rw *RecordWriter) string_memclearOn(s string, disableUTF8Check bool) {
	if disableUTF8Check || (rw.bitFlags&wFlagErrOnNonUTF8) == 0 {
		// so just need to scan for quotes, escapes, fieldSep, CR / LF / maybe all other kinds of newline sequences / recordSep

		var i int
		if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !strings.HasPrefix(s, string(rw.w.comment)) {
			i = rw.w.controlRuneSet.indexAnyInString(s)
			if i == -1 {
				rw.appendStrRec(s)
				return
			}
		}

		rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

		rw.loadStrQF_memclearOn(s, i)

		rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

		return
	}

	// for each decoded rune, check if that rune fails to decode and if so then return an error
	// if the rune is in the set of controlRunes then replace whatever needs to be replaced and
	// continue loading

	var i int
	if (rw.bitFlags&wFlagForceQuoteFirstField) == 0 || !strings.HasPrefix(s, string(rw.w.comment)) {
		for {
			if i >= len(s) {
				rw.appendStrRec(s)
				return
			}

			b := s[i]
			if b < utf8.RuneSelf {
				if !rw.w.controlRuneSet.containsSingleByteRune(b) {
					i++
					continue
				}
			} else if r, n := utf8.DecodeRuneInString(s[i:]); n == 1 {
				rw.abort(ErrNonUTF8InRecord)
				return
			} else if !rw.w.controlRuneSet.containsMBRune(r) {
				i += n
				continue
			}

			break
		}
	}

	//
	// found a control rune of some kind or was forced to quote first field
	//

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))

	err := rw.loadStrQFWithCheckUTF8_memclearOn(s, i)
	if err != nil {
		rw.abort(err)
		return
	}

	rw.setRecordBuf(rw.w.quoteSeq.appendText(rw.recordBuf))
}

func (rw *RecordWriter) int64_memclearOn(i int64) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.setRecordBuf(strconv.AppendInt(rw.recordBuf, i, 10))
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(strconv.AppendInt(rw.w.fieldWriterBuf[:0], i, 10))
}

func (rw *RecordWriter) uint64_memclearOn(i uint64) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.setRecordBuf(strconv.AppendUint(rw.recordBuf, i, 10))
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(strconv.AppendUint(rw.w.fieldWriterBuf[:0], i, 10))
}

func (rw *RecordWriter) time_memclearOn(t time.Time) {
	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.setRecordBuf(t.AppendFormat(rw.recordBuf, time.RFC3339Nano))
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(t.AppendFormat(rw.w.fieldWriterBuf[:0], time.RFC3339Nano))
}

func (rw *RecordWriter) bool_memclearOn(b bool) {

	v := byte('0')
	if b {
		v += 1
	}

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.setRecordBuf(append(rw.recordBuf, v))
		return
	}

	rw.w.fieldWriterBuf[0] = v
	rw.unsafeAppendUTF8FieldBytes_memclearOn(rw.w.fieldWriterBuf[:1])
}

func (rw *RecordWriter) float64_memclearOn(f float64) {

	if (rw.bitFlags & (wFlagControlRuneOverlap | wFlagForceQuoteFirstField)) == 0 {
		rw.setRecordBuf(strconv.AppendFloat(rw.recordBuf, f, 'g', -1, 64))
		return
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(strconv.AppendFloat(rw.w.fieldWriterBuf[:0], f, 'g', -1, 64))
}

func (rw *RecordWriter) rune_withCheckUTF8_memclearOn(r rune) {
	if !utf8.ValidRune(r) {
		rw.abort(ErrInvalidRune)
		return
	}

	if (rw.bitFlags & wFlagForceQuoteFirstField) == 0 {
		if r < utf8.RuneSelf {
			if !rw.w.controlRuneSet.containsSingleByteRune(byte(r)) {
				goto SIMPLE_APPEND
			}
		} else if !rw.w.controlRuneSet.containsMBRune(r) {
			goto SIMPLE_APPEND
		}
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(utf8.AppendRune(rw.w.fieldWriterBuf[:0], r))
	return

SIMPLE_APPEND:
	rw.setRecordBuf(utf8.AppendRune(rw.recordBuf, r))
}

func (rw *RecordWriter) rune_memclearOn(r rune) {
	if (rw.bitFlags & wFlagForceQuoteFirstField) == 0 {
		if r < utf8.RuneSelf {
			if !rw.w.controlRuneSet.containsSingleByteRune(byte(r)) {
				goto SIMPLE_APPEND
			}
		} else if !rw.w.controlRuneSet.containsMBRune(r) {
			goto SIMPLE_APPEND
		}
	}

	rw.unsafeAppendUTF8FieldBytes_memclearOn(utf8.AppendRune(rw.w.fieldWriterBuf[:0], r))
	return

SIMPLE_APPEND:
	rw.setRecordBuf(utf8.AppendRune(rw.recordBuf, r))
}

func (rw *RecordWriter) write_memclearOn() (int, error) {
	wErr := rw.w.err

	if err := rw.err; err != nil {
		if wErr == nil {
			rw.w.bitFlags |= wFlagHeaderWritten
		}

		return 0, err
	}

	switch rw.nextField {
	case 0:
		if wErr == nil {
			rw.w.bitFlags |= wFlagHeaderWritten
		}

		err := ErrRowNilOrEmpty
		rw.abort(err)
		return 0, err
	case 1:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = 1
		} else if numFields != 1 {
			if wErr == nil {
				rw.w.bitFlags |= wFlagHeaderWritten
			}

			err := ErrInvalidFieldCountInRecord
			rw.abort(err)
			return 0, err
		}
		if len(rw.recordBuf) == 0 {
			rw.setRecordBuf(rw.w.twoQuotesSeq.appendText(rw.recordBuf))
		}
	default:
		if numFields := rw.numFields; numFields == -1 {
			rw.w.numFields = rw.nextField
		} else if numFields != rw.nextField {
			if wErr == nil {
				rw.w.bitFlags |= wFlagHeaderWritten
			}

			err := ErrInvalidFieldCountInRecord
			rw.abort(err)
			return 0, err
		}
	}

	rw.setRecordBuf(rw.w.recordSepSeq.appendText(rw.recordBuf))
	rw.nextField = 0

	if wErr != nil {
		rw.abort(wErr)
		return 0, wErr
	}

	// re-checkin the buffer then flush it to the internal writer

	rw.bitFlags |= wFlagClosed
	recordBuf := rw.recordBuf
	rw.w.recordBuf = recordBuf
	rw.w.bitFlags = (rw.w.bitFlags & (^wFlagRecordBuffCheckedOut)) | (wFlagFirstRecordWritten | wFlagHeaderWritten)

	n, err := rw.w.writer.Write(recordBuf)
	if err != nil {
		err = writeIOErr{err}
		if rw.w.err == nil {
			rw.w.setErr(err)
		}

		// no need to re-unset the rw.bitFlags wFlagClosed bit since
		// the parent writer context now owns the record buffer again
		//
		// parent writer will clear it when closed

		rw.abort(err)
	} else {
		rw.err = ErrRecordWritten
	}
	return n, err
}

// loadQF_memclearOff is called after a
// quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and communicate to this function where to
// start scanning in the source for characters to escape. The parent context will not write any part of
// the source to the record staging zone.
//
// Essentially the function picks up after the parent context starts a quoting process which the parent
// will also complete.
func (wb *writeBuffer) loadQF_memclearOff(p []byte, scanIdx int) {
	r, n, i := wb.escapeControlRuneSet.indexAnyRuneLenInBytes(p[scanIdx:])
	if i == -1 {
		wb.recordBuf = append(wb.recordBuf, p...)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	wb.recordBuf = append(wb.recordBuf, p[:scanIdx]...)

	for {
		scanIdx += int(n)

		if wb.quote == r {
			wb.recordBuf = wb.escapedQuoteSeq.appendText(wb.recordBuf)
		} else {
			wb.recordBuf = wb.escapedEscapeSeq.appendText(wb.recordBuf)
		}

		r, n, i = wb.escapeControlRuneSet.indexAnyRuneLenInBytes(p[scanIdx:])
		if i == -1 {
			wb.recordBuf = append(wb.recordBuf, p[scanIdx:]...)
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		wb.recordBuf = append(wb.recordBuf, p[prevIdx:scanIdx]...)
	}
}

// loadQFWithCheckUTF8_memclearOff performs the same duties as loadQF_memclearOff and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (wb *writeBuffer) loadQFWithCheckUTF8_memclearOff(p []byte, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(p) {
			wb.recordBuf = append(wb.recordBuf, p[loadIdx:]...)
			return nil
		}

		if b := p[scanIdx]; b < utf8.RuneSelf {
			if !wb.escapeControlRuneSet.containsSingleByteRune(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRune(p[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !wb.escapeControlRuneSet.containsMBRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		wb.recordBuf = append(wb.recordBuf, p[loadIdx:scanIdx]...)

		scanIdx += n
		loadIdx = scanIdx

		if wb.quote == r {
			wb.recordBuf = wb.escapedQuoteSeq.appendText(wb.recordBuf)
			continue
		}

		wb.recordBuf = wb.escapedEscapeSeq.appendText(wb.recordBuf)
	}
}

// loadStrQF_memclearOff is called after a
// quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and communicate to this function where to
// start scanning in the source for characters to escape. The parent context will not write any part of
// the source to the record staging zone.
//
// Essentially the function picks up after the parent context starts a quoting process which the parent
// will also complete.
func (wb *writeBuffer) loadStrQF_memclearOff(s string, scanIdx int) {
	r, n, i := wb.escapeControlRuneSet.indexAnyRuneLenInString(s[scanIdx:])
	if i == -1 {
		wb.recordBuf = append(wb.recordBuf, s...)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	wb.recordBuf = append(wb.recordBuf, s[:scanIdx]...)

	for {
		scanIdx += int(n)

		if wb.quote == r {
			wb.recordBuf = wb.escapedQuoteSeq.appendText(wb.recordBuf)
		} else {
			wb.recordBuf = wb.escapedEscapeSeq.appendText(wb.recordBuf)
		}

		r, n, i = wb.escapeControlRuneSet.indexAnyRuneLenInString(s[scanIdx:])
		if i == -1 {
			wb.recordBuf = append(wb.recordBuf, s[scanIdx:]...)
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		wb.recordBuf = append(wb.recordBuf, s[prevIdx:scanIdx]...)
	}
}

// loadStrQFWithCheckUTF8_memclearOff performs the same duties as loadStrQF_memclearOff and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (wb *writeBuffer) loadStrQFWithCheckUTF8_memclearOff(s string, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(s) {
			wb.recordBuf = append(wb.recordBuf, s[loadIdx:]...)
			return nil
		}

		if b := s[scanIdx]; b < utf8.RuneSelf {
			if !wb.escapeControlRuneSet.containsSingleByteRune(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRuneInString(s[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !wb.escapeControlRuneSet.containsMBRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		wb.recordBuf = append(wb.recordBuf, s[loadIdx:scanIdx]...)

		scanIdx += n
		loadIdx = scanIdx

		if wb.quote == r {
			wb.recordBuf = wb.escapedQuoteSeq.appendText(wb.recordBuf)
			continue
		}

		wb.recordBuf = wb.escapedEscapeSeq.appendText(wb.recordBuf)
	}
}

// loadQF_memclearOn is called after a
// quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and communicate to this function where to
// start scanning in the source for characters to escape. The parent context will not write any part of
// the source to the record staging zone.
//
// Essentially the function picks up after the parent context starts a quoting process which the parent
// will also complete.
func (wb *writeBuffer) loadQF_memclearOn(p []byte, scanIdx int) {
	r, n, i := wb.escapeControlRuneSet.indexAnyRuneLenInBytes(p[scanIdx:])
	if i == -1 {
		wb.appendRec(p)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	wb.appendRec(p[:scanIdx])

	for {
		scanIdx += int(n)

		if wb.quote == r {
			wb.setRecordBuf(wb.escapedQuoteSeq.appendText(wb.recordBuf))
		} else {
			wb.setRecordBuf(wb.escapedEscapeSeq.appendText(wb.recordBuf))
		}

		r, n, i = wb.escapeControlRuneSet.indexAnyRuneLenInBytes(p[scanIdx:])
		if i == -1 {
			wb.appendRec(p[scanIdx:])
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		wb.appendRec(p[prevIdx:scanIdx])
	}
}

// loadQFWithCheckUTF8_memclearOn performs the same duties as loadQF_memclearOn and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (wb *writeBuffer) loadQFWithCheckUTF8_memclearOn(p []byte, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(p) {
			wb.appendRec(p[loadIdx:])
			return nil
		}

		if b := p[scanIdx]; b < utf8.RuneSelf {
			if !wb.escapeControlRuneSet.containsSingleByteRune(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRune(p[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !wb.escapeControlRuneSet.containsMBRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		wb.appendRec(p[loadIdx:scanIdx])

		scanIdx += n
		loadIdx = scanIdx

		if wb.quote == r {
			wb.setRecordBuf(wb.escapedQuoteSeq.appendText(wb.recordBuf))
			continue
		}

		wb.setRecordBuf(wb.escapedEscapeSeq.appendText(wb.recordBuf))
	}
}

// loadStrQF_memclearOn is called after a
// quote, escape, or csv format sensitive character is found in the field data.
// The parent context will handle wrapping the field in quotes and communicate to this function where to
// start scanning in the source for characters to escape. The parent context will not write any part of
// the source to the record staging zone.
//
// Essentially the function picks up after the parent context starts a quoting process which the parent
// will also complete.
func (wb *writeBuffer) loadStrQF_memclearOn(s string, scanIdx int) {
	r, n, i := wb.escapeControlRuneSet.indexAnyRuneLenInString(s[scanIdx:])
	if i == -1 {
		wb.appendStrRec(s)
		return
	}
	scanIdx += i

	//
	// found a control rune of some kind that must be escaped
	//

	wb.appendStrRec(s[:scanIdx])

	for {
		scanIdx += int(n)

		if wb.quote == r {
			wb.setRecordBuf(wb.escapedQuoteSeq.appendText(wb.recordBuf))
		} else {
			wb.setRecordBuf(wb.escapedEscapeSeq.appendText(wb.recordBuf))
		}

		r, n, i = wb.escapeControlRuneSet.indexAnyRuneLenInString(s[scanIdx:])
		if i == -1 {
			wb.appendStrRec(s[scanIdx:])
			return
		}

		prevIdx := scanIdx
		scanIdx += i
		wb.appendStrRec(s[prevIdx:scanIdx])
	}
}

// loadStrQFWithCheckUTF8_memclearOn performs the same duties as loadStrQF_memclearOn and in a much more expensive
// scan operation also validates that the field contents are valid utf8 sequences.
func (wb *writeBuffer) loadStrQFWithCheckUTF8_memclearOn(s string, scanIdx int) error {
	var loadIdx, n int
	var r rune
	for {
		if scanIdx >= len(s) {
			wb.appendStrRec(s[loadIdx:])
			return nil
		}

		if b := s[scanIdx]; b < utf8.RuneSelf {
			if !wb.escapeControlRuneSet.containsSingleByteRune(b) {
				scanIdx++
				continue
			}
			r = rune(b)
			n = 1
		} else if r, n = utf8.DecodeRuneInString(s[scanIdx:]); n == 1 {
			return ErrNonUTF8InRecord
		} else if !wb.escapeControlRuneSet.containsMBRune(r) {
			scanIdx += n
			continue
		}

		//
		// found a control rune of some kind that must be escaped
		//

		wb.appendStrRec(s[loadIdx:scanIdx])

		scanIdx += n
		loadIdx = scanIdx

		if wb.quote == r {
			wb.setRecordBuf(wb.escapedQuoteSeq.appendText(wb.recordBuf))
			continue
		}

		wb.setRecordBuf(wb.escapedEscapeSeq.appendText(wb.recordBuf))
	}
}
