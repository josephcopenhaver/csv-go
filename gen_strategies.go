// Code generated by ./internal/cmd/generate/main.go DO NOT EDIT.

package csv

import (
	"errors"
	"io"
	"unicode/utf8"
	"unsafe"
)

func (r *Reader) prepareRow_memclearOff() bool {

	for {
		c, size, rErr := r.reader.ReadRune()
		if size > 0 && rErr != nil {
			r.setDone()
			r.ioErr(errors.Join(ErrBadReadRuneImpl, rErr))
			return false
		}

		// advance the position indicator
		r.byteIndex += uint64(size)

		if size == 1 && c == utf8.RuneError {

			//
			// handle a non UTF8 byte
			//

			if r.state == rStateStartOfDoc {
				if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
					r.byteIndex = 0 // special case, no BOM rune was found while at start of doc so no processed bytes were "stable"
					r.setDone()
					r.parsingErr(ErrNoByteOrderMarker)
					return false
				}

				r.state = rStateStartOfRecord
			}

			if err := r.reader.UnreadRune(); err != nil {
				r.setDone()
				r.ioErr(errors.Join(ErrBadUnreadRuneImpl, err))
				return false
			}
			var b byte
			if v, err := r.reader.ReadByte(); err != nil {
				r.setDone()
				r.ioErr(errors.Join(ErrBadReadByteImpl, err))
				return false
			} else {
				b = v
			}

			switch r.state {
			case rStateStartOfRecord, rStateStartOfField:
				r.recordBuf = append(r.recordBuf, b)
				r.state = rStateInField
			case rStateInField, rStateInQuotedField:
				r.recordBuf = append(r.recordBuf, b)
				// r.state = rStateInField
			// case rStateInQuotedField:
			// 	r.recordBuf = append(r.recordBuf, b)
			// 	// r.state = rStateInQuotedField
			case rStateInQuotedFieldAfterEscape:
				r.setDone()
				r.parsingErr(errInvalidEscapeInQuotedFieldUnexpectedByte)
				return false
			case rStateEndOfQuotedField:
				r.setDone()
				r.parsingErr(ErrInvalidQuotedFieldEnding)
				return false
				// case rStateInLineComment:
				// 	// r.state = rStateInLineComment
			}

			if rErr == nil {
				continue
			}
		}
		if rErr != nil {
			r.setDone()
			if errors.Is(rErr, io.EOF) {
				return r.handleEOF()
			}
			r.ioErr(rErr)
			return false
		}

		switch r.state {
		case rStateStartOfDoc:
			if !isByteOrderMarker(uint32(c), size) {
				if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
					r.byteIndex = 0 // special case, no BOM rune was found while at start of doc so no processed bytes were "stable"
					r.setDone()
					r.parsingErr(ErrNoByteOrderMarker)
					return false
				}
			} else if (r.bitFlags & rFlagDropBOM) != 0 {
				r.state = rStateStartOfRecord
				continue
			}

			r.state = rStateStartOfRecord
			fallthrough
		case rStateStartOfRecord:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				// r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 {
				r.state = rStateInQuotedField

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			if c == r.comment && (r.bitFlags&rFlagComment) != 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
				r.state = rStateInLineComment

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.recordBuf = append(r.recordBuf, []byte(string(c))...)
			r.state = rStateInField
		case rStateStartOfField:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				// r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 {
				r.state = rStateInQuotedField

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.recordBuf = append(r.recordBuf, []byte(string(c))...)
			r.state = rStateInField
		case rStateInField:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 && (r.bitFlags&rFlagErrOnQInUF) != 0 {
				r.setDone()
				r.parsingErr(ErrQuoteInUnquotedField)
				return false
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.recordBuf = append(r.recordBuf, []byte(string(c))...)
			// r.state = rStateInField
		case rStateInQuotedField:
			switch c {
			case r.quote:
				r.state = rStateEndOfQuotedField
			default:
				if c == r.escape && (r.bitFlags&rFlagEscape) != 0 {
					r.state = rStateInQuotedFieldAfterEscape
					continue
				}

				r.recordBuf = append(r.recordBuf, []byte(string(c))...)
				// r.state = rStateInQuotedField
			}
		case rStateInQuotedFieldAfterEscape:
			switch c {
			case r.quote, r.escape:
				r.recordBuf = append(r.recordBuf, []byte(string(c))...)
				r.state = rStateInQuotedField
			default:
				r.setDone()
				r.parsingErr(errInvalidEscapeInQuotedFieldUnexpectedRune)
				return false
			}
		case rStateEndOfQuotedField:
			switch c {
			case r.fieldSeparator:
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++
			case r.quote:
				if (r.bitFlags & rFlagEscape) != 0 {
					r.setDone()
					r.parsingErr(ErrUnexpectedQuoteAfterField)
					return false
				}
				r.recordBuf = append(r.recordBuf, []byte(string(r.quote))...)
				r.state = rStateInQuotedField
			default:
				isRecSep, immediateErr := r.isRecordSeparator(c)
				if immediateErr {
					return false
				}
				if isRecSep {
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)
					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.fieldIndex = 0
						r.recordIndex++
						return true
					}
					return false
				}

				r.setDone()
				r.parsingErr(ErrInvalidQuotedFieldEnding)
				return false
			}
		case rStateInLineComment:
			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.state = rStateStartOfRecord
				// r.recordIndex++ // not valid in this case because the previous state was not a record
			}

			continue
		}

		// not required because all code paths that would set this value
		// end in early returns rather than continued iterations
		//
		//
		// if r.eof {
		// 	break
		// }

		// not required because all code paths that would set this value
		// end in early returns rather than continued iterations
		//
		// these paths include calls to:
		// - nextRuneIsLF()
		// - fieldNumOverflow()
		// - checkFields()
		//
		// and every path in prepareRow() that sets `r.done = <true-expression>`
		//
		//
		// if r.done {
		// 	break
		// }

		// now, because all code paths that would call break are definitely not viable
		// there does not need to be anything after this loop all exit points are returns
	}

	// no longer required because all loop exit points are returns, no breaks
	//
	//
	// var errTrailer error
	// if r.eof {
	// 	errTrailer = io.ErrUnexpectedEOF
	// }
	// return r.checkNumFields(errTrailer)
}

func (r *Reader) prepareRow_memclearOn() bool {

	for {
		c, size, rErr := r.reader.ReadRune()
		if size > 0 && rErr != nil {
			r.setDone()
			r.ioErr(errors.Join(ErrBadReadRuneImpl, rErr))
			return false
		}

		// advance the position indicator
		r.byteIndex += uint64(size)

		if size == 1 && c == utf8.RuneError {

			//
			// handle a non UTF8 byte
			//

			if r.state == rStateStartOfDoc {
				if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
					r.byteIndex = 0 // special case, no BOM rune was found while at start of doc so no processed bytes were "stable"
					r.setDone()
					r.parsingErr(ErrNoByteOrderMarker)
					return false
				}

				r.state = rStateStartOfRecord
			}

			if err := r.reader.UnreadRune(); err != nil {
				r.setDone()
				r.ioErr(errors.Join(ErrBadUnreadRuneImpl, err))
				return false
			}
			var b byte
			if v, err := r.reader.ReadByte(); err != nil {
				r.setDone()
				r.ioErr(errors.Join(ErrBadReadByteImpl, err))
				return false
			} else {
				b = v
			}

			switch r.state {
			case rStateStartOfRecord, rStateStartOfField:
				r.appendRecBuf(b)
				r.state = rStateInField
			case rStateInField, rStateInQuotedField:
				r.appendRecBuf(b)
				// r.state = rStateInField
			// case rStateInQuotedField:
			// 	r.appendRecBuf(b)
			// 	// r.state = rStateInQuotedField
			case rStateInQuotedFieldAfterEscape:
				r.setDone()
				r.parsingErr(errInvalidEscapeInQuotedFieldUnexpectedByte)
				return false
			case rStateEndOfQuotedField:
				r.setDone()
				r.parsingErr(ErrInvalidQuotedFieldEnding)
				return false
				// case rStateInLineComment:
				// 	// r.state = rStateInLineComment
			}

			if rErr == nil {
				continue
			}
		}
		if rErr != nil {
			r.setDone()
			if errors.Is(rErr, io.EOF) {
				return r.handleEOF()
			}
			r.ioErr(rErr)
			return false
		}

		switch r.state {
		case rStateStartOfDoc:
			if !isByteOrderMarker(uint32(c), size) {
				if (r.bitFlags & rFlagErrOnNoBOM) != 0 {
					r.byteIndex = 0 // special case, no BOM rune was found while at start of doc so no processed bytes were "stable"
					r.setDone()
					r.parsingErr(ErrNoByteOrderMarker)
					return false
				}
			} else if (r.bitFlags & rFlagDropBOM) != 0 {
				r.state = rStateStartOfRecord
				continue
			}

			r.state = rStateStartOfRecord
			fallthrough
		case rStateStartOfRecord:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				// r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 {
				r.state = rStateInQuotedField

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			if c == r.comment && (r.bitFlags&rFlagComment) != 0 && ((r.bitFlags&stAfterSOR) == 0 || (r.bitFlags&rFlagCommentAfterSOR) != 0) {
				r.state = rStateInLineComment

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.appendRecBuf([]byte(string(c))...)
			r.state = rStateInField
		case rStateStartOfField:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				// r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, 0)
				// field start is unchanged because the last one was zero length
				// r.fieldStart = len(r.recordBuf)
				r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 {
				r.state = rStateInQuotedField

				// not required because quote being set to \r is not allowed when record sep discovery mode is enabled
				//
				//
				// // checking if EOF was signaled from within the isRecordSeparator call before continue
				// if r.eof {
				// 	break
				// }
				continue
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.appendRecBuf([]byte(string(c))...)
			r.state = rStateInField
		case rStateInField:
			if c == r.fieldSeparator {
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++

				continue
			}

			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				r.state = rStateStartOfRecord
				if r.checkNumFields(nil) {
					r.fieldIndex = 0
					r.recordIndex++
					return true
				}
				return false
			}

			if c == r.quote && (r.bitFlags&rFlagQuote) != 0 && (r.bitFlags&rFlagErrOnQInUF) != 0 {
				r.setDone()
				r.parsingErr(ErrQuoteInUnquotedField)
				return false
			}

			switch c {
			case '\r':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldCarriageReturn)
					return false
				}
			case '\n':
				if (r.bitFlags & rFlagErrOnNLInUF) != 0 {
					r.setDone()
					r.parsingErr(errNewlineInUnquotedFieldLineFeed)
					return false
				}
			}

			r.appendRecBuf([]byte(string(c))...)
			// r.state = rStateInField
		case rStateInQuotedField:
			switch c {
			case r.quote:
				r.state = rStateEndOfQuotedField
			default:
				if c == r.escape && (r.bitFlags&rFlagEscape) != 0 {
					r.state = rStateInQuotedFieldAfterEscape
					continue
				}

				r.appendRecBuf([]byte(string(c))...)
				// r.state = rStateInQuotedField
			}
		case rStateInQuotedFieldAfterEscape:
			switch c {
			case r.quote, r.escape:
				r.appendRecBuf([]byte(string(c))...)
				r.state = rStateInQuotedField
			default:
				r.setDone()
				r.parsingErr(errInvalidEscapeInQuotedFieldUnexpectedRune)
				return false
			}
		case rStateEndOfQuotedField:
			switch c {
			case r.fieldSeparator:
				r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
				r.fieldStart = len(r.recordBuf)
				if r.fieldNumOverflow() {
					return false
				}
				r.state = rStateStartOfField
				r.fieldIndex++
			case r.quote:
				if (r.bitFlags & rFlagEscape) != 0 {
					r.setDone()
					r.parsingErr(ErrUnexpectedQuoteAfterField)
					return false
				}
				r.appendRecBuf([]byte(string(r.quote))...)
				r.state = rStateInQuotedField
			default:
				isRecSep, immediateErr := r.isRecordSeparator(c)
				if immediateErr {
					return false
				}
				if isRecSep {
					r.fieldLengths = append(r.fieldLengths, len(r.recordBuf)-r.fieldStart)
					r.fieldStart = len(r.recordBuf)
					r.state = rStateStartOfRecord
					if r.checkNumFields(nil) {
						r.fieldIndex = 0
						r.recordIndex++
						return true
					}
					return false
				}

				r.setDone()
				r.parsingErr(ErrInvalidQuotedFieldEnding)
				return false
			}
		case rStateInLineComment:
			isRecSep, immediateErr := r.isRecordSeparator(c)
			if immediateErr {
				return false
			}
			if isRecSep {
				r.state = rStateStartOfRecord
				// r.recordIndex++ // not valid in this case because the previous state was not a record
			}

			continue
		}

		// not required because all code paths that would set this value
		// end in early returns rather than continued iterations
		//
		//
		// if r.eof {
		// 	break
		// }

		// not required because all code paths that would set this value
		// end in early returns rather than continued iterations
		//
		// these paths include calls to:
		// - nextRuneIsLF()
		// - fieldNumOverflow()
		// - checkFields()
		//
		// and every path in prepareRow() that sets `r.done = <true-expression>`
		//
		//
		// if r.done {
		// 	break
		// }

		// now, because all code paths that would call break are definitely not viable
		// there does not need to be anything after this loop all exit points are returns
	}

	// no longer required because all loop exit points are returns, no breaks
	//
	//
	// var errTrailer error
	// if r.eof {
	// 	errTrailer = io.ErrUnexpectedEOF
	// }
	// return r.checkNumFields(errTrailer)
}

func (w *Writer) processField_escapeUnset_quoteUnforced_memclearDisabled(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeDisabled_memclearDisabled(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeSet_quoteUnforced_memclearDisabled(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		case w.escape:
			w.fieldBuf = append(w.fieldBuf, v[:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeEnabled_memclearDisabled(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeUnset_quoteForced_memclearDisabled(v []byte) (int, error) {

	n, err := w.escapeChars_escapeDisabled_memclearDisabled(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeSet_quoteForced_memclearDisabled(v []byte) (int, error) {

	n, err := w.escapeChars_escapeEnabled_memclearDisabled(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeUnset_quoteUnforced_memclearEnabled(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeDisabled_memclearEnabled(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeSet_quoteUnforced_memclearEnabled(v []byte) (int, error) {
	var si, i, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return -1, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return -1, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		case w.escape:
			w.appendField(v[:i], w.escapedEscape[:w.escapedEscapeByteLen])

			i += di
			si = i
		default:
			i += di

			if !w.runeRequiresQuotes(r) {
				continue
			}
		}

		break
	}

	si2, err := w.escapeChars_escapeEnabled_memclearEnabled(v[si:], i-si)
	if err != nil {
		return -1, err
	}

	return si + si2, nil
}

func (w *Writer) processField_escapeUnset_quoteForced_memclearEnabled(v []byte) (int, error) {

	n, err := w.escapeChars_escapeDisabled_memclearEnabled(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) processField_escapeSet_quoteForced_memclearEnabled(v []byte) (int, error) {

	n, err := w.escapeChars_escapeEnabled_memclearEnabled(v, 0)
	if err != nil {
		return -1, err
	}

	return n, nil
}

func (w *Writer) escapeChars_escapeDisabled_memclearDisabled(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeEnabled_memclearDisabled(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedQuote[:w.escapedQuoteByteLen]...)

			i += di
			si = i
		case w.escape:
			w.fieldBuf = append(w.fieldBuf, v[si:i]...)
			w.fieldBuf = append(w.fieldBuf, w.escapedEscape[:w.escapedEscapeByteLen]...)

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeDisabled_memclearEnabled(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[si:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) escapeChars_escapeEnabled_memclearEnabled(v []byte, i int) (int, error) {
	var si, di int
	var r rune

	for {
		r, di = utf8.DecodeRune(v[i:])
		switch di {
		case 0:
			return si, nil
		case 1:
			if r == utf8.RuneError {
				if w.errOnNonUTF8 {
					return 0, ErrNonUTF8InRecord
				}

				i += di
				continue
			}
		}

		switch r {
		case w.quote:
			w.appendField(v[si:i], w.escapedQuote[:w.escapedQuoteByteLen])

			i += di
			si = i
		case w.escape:
			w.appendField(v[si:i], w.escapedEscape[:w.escapedEscapeByteLen])

			i += di
			si = i
		default:
			i += di
		}
	}
}

func (w *Writer) writeRow_memclearDisabled(row []string) (int, error) {
	defer func() {
		w.recordBuf = w.recordBuf[:0]
	}()

	if len(row) == 0 {
		return 0, ErrRowNilOrEmpty
	}

	if w.numFields != len(row) {
		if w.numFields != -1 {
			return 0, ErrInvalidFieldCountInRecord
		}

		w.numFields = len(row)
	}

	if len(row) == 1 && row[0] == "" {
		// This is a safety feature that makes the document slightly more durable to being edited.
		// If we could guarantee that the "record terminator" is never removed by accident via
		// "whitespace removal" of editors then this is extra work with no benefit. If this ever
		// becomes disable-allowed then I would still default it to enabled behavior.

		// note that this creates quite a bit of extra characters at times
		// ideally only the last row would have this escaping as most parsers
		// would understand the rows in-between as empty-value cells
		//
		// doing this would require that we buffer the last written line
		// and either add a close or flush function we expect persons to call
		//
		// but then again this only affects tables where there is one and only one attribute that is often an empty string
		//
		// seems like an odd path to optimize for, but we could
		w.writeDoubleQuotesForRecord()
	} else {
		if err := w.writeField_memclearDisabled(w.processFirstField, row[0]); err != nil {
			return 0, err
		}

		for _, v := range row[1:] {

			// write field separator
			w.recordBuf = append(w.recordBuf, []byte(string(w.fieldSep))...)

			if err := w.writeField_memclearDisabled(w.processField, v); err != nil {
				return 0, err
			}
		}
	}

	w.recordBuf = append(w.recordBuf, w.recordSepBytes[:w.recordSepByteLen]...)

	w.recordWritten = true
	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err := writeIOErr{err}
		w.setErr(err)
		return n, err
	}

	return n, nil
}

func (w *Writer) writeDoubleQuotesForRecord_memclearDisabled() {
	w.recordBuf = append(w.recordBuf, w.twoQuotes[:w.twoQuotesByteLen]...)
}

func (w *Writer) writeField_memclearDisabled(processField func([]byte) (int, error), input string) error {
	if input == "" {
		return nil
	}
	defer func() {
		w.fieldBuf = w.fieldBuf[:0]
	}()

	// v here is immutable
	//
	// unsafe may look concerning and scary, and it can be,
	// however in this case we're never writing to the slice
	// created here which is stored within `v`
	//
	// since strings are immutable as well this is actually a safe
	// usage of the unsafe package to avoid an allocation we're
	// just going to read from and then throw away before this
	// returns
	//
	// It will also never be called if the len is zero,
	// just as an extra precaution.
	v := unsafe.Slice(unsafe.StringData(input), len(input))

	si, err := processField(v)
	if err != nil {

		return err
	} else if si == -1 {
		// w.fieldBuf is guaranteed to be empty on this code path
		//
		// use v instead
		w.recordBuf = append(w.recordBuf, v...)

		return nil
	}

	// w.fieldBuf might have a len greater than zero on this code path
	// if it does then use it

	w.recordBuf = append(w.recordBuf, []byte(string(w.quote))...)
	if len(w.fieldBuf) > 0 {
		w.recordBuf = append(w.recordBuf, w.fieldBuf...)
		w.recordBuf = append(w.recordBuf, v[si:]...)

	} else {
		w.recordBuf = append(w.recordBuf, v...)
	}
	w.recordBuf = append(w.recordBuf, []byte(string(w.quote))...)

	return nil
}

func (w *Writer) writeRow_memclearEnabled(row []string) (int, error) {
	defer func() {
		w.recordBuf = w.recordBuf[:0]
	}()

	if len(row) == 0 {
		return 0, ErrRowNilOrEmpty
	}

	if w.numFields != len(row) {
		if w.numFields != -1 {
			return 0, ErrInvalidFieldCountInRecord
		}

		w.numFields = len(row)
	}

	if len(row) == 1 && row[0] == "" {
		// This is a safety feature that makes the document slightly more durable to being edited.
		// If we could guarantee that the "record terminator" is never removed by accident via
		// "whitespace removal" of editors then this is extra work with no benefit. If this ever
		// becomes disable-allowed then I would still default it to enabled behavior.

		// note that this creates quite a bit of extra characters at times
		// ideally only the last row would have this escaping as most parsers
		// would understand the rows in-between as empty-value cells
		//
		// doing this would require that we buffer the last written line
		// and either add a close or flush function we expect persons to call
		//
		// but then again this only affects tables where there is one and only one attribute that is often an empty string
		//
		// seems like an odd path to optimize for, but we could
		w.writeDoubleQuotesForRecord()
	} else {
		if err := w.writeField_memclearEnabled(w.processFirstField, row[0]); err != nil {
			return 0, err
		}

		for _, v := range row[1:] {

			// write field separator
			w.appendRec([]byte(string(w.fieldSep)))

			if err := w.writeField_memclearEnabled(w.processField, v); err != nil {
				return 0, err
			}
		}
	}

	w.appendRec(w.recordSepBytes[:w.recordSepByteLen])

	w.recordWritten = true
	n, err := w.writer.Write(w.recordBuf)
	if err != nil {
		err := writeIOErr{err}
		w.setErr(err)
		return n, err
	}

	return n, nil
}

func (w *Writer) writeDoubleQuotesForRecord_memclearEnabled() {
	w.appendRec(w.twoQuotes[:w.twoQuotesByteLen])
}

func (w *Writer) writeField_memclearEnabled(processField func([]byte) (int, error), input string) error {
	if input == "" {
		return nil
	}
	defer func() {
		w.fieldBuf = w.fieldBuf[:0]
	}()

	// v here is immutable
	//
	// unsafe may look concerning and scary, and it can be,
	// however in this case we're never writing to the slice
	// created here which is stored within `v`
	//
	// since strings are immutable as well this is actually a safe
	// usage of the unsafe package to avoid an allocation we're
	// just going to read from and then throw away before this
	// returns
	//
	// It will also never be called if the len is zero,
	// just as an extra precaution.
	v := unsafe.Slice(unsafe.StringData(input), len(input))

	si, err := processField(v)
	if err != nil {

		return err
	} else if si == -1 {
		// w.fieldBuf is guaranteed to be empty on this code path
		//
		// use v instead
		w.appendRec(v)

		return nil
	}

	// w.fieldBuf might have a len greater than zero on this code path
	// if it does then use it

	w.appendRec([]byte(string(w.quote)))
	if len(w.fieldBuf) > 0 {
		w.appendRec(w.fieldBuf, v[si:])

	} else {
		w.appendRec(v)
	}
	w.appendRec([]byte(string(w.quote)))

	return nil
}
